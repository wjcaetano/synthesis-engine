# This recipe uses only cypher queries to retrieve cobol components
# Its defect is not presenting any sql-statement in callgraph and transcription
config:
  fresh: true
  transformDefaultParams:
    jolt:
      - "${#recipe['templates']['joltNeo4jTableToJson']}"
    neo4j:
      - "${@Utils.getEnvVariable('NEO4J_API_URI')}"
      - "${@Utils.createBasicAuthHeader(@Utils.getEnvVariable('NEO4J_USERNAME'), @Utils.getEnvVariable('NEO4J_PASSWORD'))}"
  options:
    - name: programming_language
      type: DROPDOWN
      label: "Programming Language"
      defaultValue: COBOL
      values:
        - label: COBOL
          value: COBOL
        - label: C#
          value: CSharp
        - label: Java
          value: Java
    - name: byID
      type: BOOLEAN
      label: "By ID"
      defaultValue: false
    - name: splitByProgram
      type: BOOLEAN
      label: "Split By Program"
      defaultValue: false
executor: ProjectModelExecutor.java
executorEvents:
  beforeAll: |-
    @@@_exec("${#recipe['templates']['listOfJcls']}")
    @@@_exec("${#recipe['templates']['programs']}")
    @@@_exec("${#recipe['templates']['screens']}")
    @@@_exec("${#recipe['templates']['paragraphVariables']}")
projectsReference: "${@Utils.convertToConcurrent(#$api['configs']['options']['splitByProgram'] ? #programs : {{'name': 'tech-files'}})}"
projectSuperModel: null
projectModel:
  callgraph.txt: "${#recipe['templates']['callgraph'][#$api['configs']['options']['programming_language']]}"
  tech-transcription.txt: "${#recipe['templates']['tech'][#$api['configs']['options']['programming_language']]}"
templates:
  listOfJcls: |-
    @@@neo4j
    @@@jolt
    @@@spel("${#content == null || #content == 'null' ? '[]' : #content }")
    @@@objectify(null, "listOfJcls")
    MATCH (jcl:COBOLJcl)
    OPTIONAL MATCH (jcl)-[:RELATES_TO]->(cp:COBOLProgram)
    RETURN
      id(jcl)           AS id,
      jcl.name          AS name,
      jcl.type          AS type,
      jcl.rawCode       AS rawCode,
      [p IN COLLECT(DISTINCT cp.name) WHERE p IS NOT NULL | {name: p}] AS programs
  programs: |-
    @@@neo4j
    @@@jolt
    @@@spel("${#content == null || #content == 'null' ? '[]' : #content }")
    @@@objectify(null, "programs")
    MATCH (cp:COBOLProgram)
    OPTIONAL MATCH (cp)<-[:DEPENDS_ON]-(cp2:COBOLProgram)
    OPTIONAL MATCH (cp)<-[:RELATES_TO]-(jcl:COBOLJcl)
    OPTIONAL MATCH (cp)-[:CONTAINS]->(cid:COBOLIdentificationDivision)
    OPTIONAL MATCH (cp)-[:CONTAINS]->(ced:COBOLEnvironmentDivision)
    OPTIONAL MATCH (ced)-[:CONTAINS]->(cis:COBOLInputOutputSection)-[:CONTAINS]->(cfc:COBOLFileControl|COBOLVsamFile)
    OPTIONAL MATCH (cp)-[:CONTAINS]->(cdd:COBOLDataDivision)
    OPTIONAL MATCH (cdd)-[:CONTAINS]->(cddb:COBOLCopyBook)
    OPTIONAL MATCH (cdd)-[:CONTAINS]->(cfs:COBOLFileSection)-[:CONTAINS]->(cfr:COBOLFileRecord)
    OPTIONAL MATCH (cdd)-[:CONTAINS]->(cws:COBOLWorkingStorageSection)
    OPTIONAL MATCH (cdd)-[:CONTAINS]->(cls:COBOLLinkageSection)
    OPTIONAL MATCH (cp)-[:CONTAINS]->(cpd:COBOLProcedureDivision)-[:CONTAINS]->(par:COBOLParagraph)
    OPTIONAL MATCH (cpd)-[:CONTAINS]->(cpb:COBOLCopyBook)
    OPTIONAL MATCH (par)-[:CONTAINS]->(parc:COBOLCall)
    OPTIONAL MATCH (par)-[:CONTAINS]->(parp:COBOLPerform)
    WITH cp, par, cid, ced, cdd, cpd,
    [p IN COLLECT(DISTINCT cpb) WHERE p.name IS NOT NULL | {id: id(p), name: p.name, rawCode: p.rawCode}] AS procedureDivisionCopybooks,
    [p IN COLLECT(DISTINCT cddb) WHERE p.name IS NOT NULL | {id: id(p), name: p.name, rawCode: p.rawCode}] AS dataDivisionCopybooks,
    [p IN COLLECT(DISTINCT cfr) WHERE p.name IS NOT NULL | {id: id(p), name: p.name, rawCode: p.rawCode}] AS dataDivisionFileSection,
    CASE WHEN cws.rawCode IS NOT NULL THEN {id: id(cws), rawCode: cws.rawCode} ELSE null END AS dataDivisionWorkingStorageSection,
    CASE WHEN cls.rawCode IS NOT NULL THEN {id: id(cls), rawCode: cls.rawCode} ELSE null END AS dataDivisionLinkageSection,
    [p IN COLLECT(DISTINCT cfc) WHERE p.name IS NOT NULL | {name: p.name}] AS environmentDivisionInputOutputSection,
    [p IN COLLECT(DISTINCT cp2) WHERE p.name IS NOT NULL | {name: p.name}] AS listOfParentCobolProgram,
    [p IN COLLECT(DISTINCT jcl) WHERE p.name IS NOT NULL | {name: p.name}] AS listOfParentJcl,
    [p IN COLLECT(DISTINCT parc) WHERE p.name IS NOT NULL | {name: p.name, arguments: p.arguments}] AS calls,
    [p IN COLLECT(DISTINCT parp) WHERE p.name IS NOT NULL | {name: p.name, arguments: p.arguments}] AS performs
    WITH cp, cid, ced, cdd, cpd, listOfParentJcl, listOfParentCobolProgram, dataDivisionCopybooks, dataDivisionFileSection, dataDivisionWorkingStorageSection, dataDivisionLinkageSection, procedureDivisionCopybooks, environmentDivisionInputOutputSection,
    COLLECT(DISTINCT {
      id: id(par),
      name: par.name,
      rawCode: par.rawCode,
      calls: calls,
      performs: performs
    }) AS paragraphs
    RETURN
        cp.name     AS name,
        listOfParentCobolProgram AS listOfParentCobolProgram,
        listOfParentJcl AS listOfParentJcl,   
        { id: id(cid), rawCode: cid.rawCode } AS identificationDivision,
        { id: id(ced), rawCode: ced.rawCode, inputOutputSection: environmentDivisionInputOutputSection } AS environmentDivision,
        { id: id(cdd), copyBooks: dataDivisionCopybooks, fileSection: dataDivisionFileSection, workingStorageSection: dataDivisionWorkingStorageSection, linkageSection: dataDivisionLinkageSection } AS dataDivision,
        { id: id(cpd), copyBooks: procedureDivisionCopybooks } AS procedureDivision,
        paragraphs
  screens: |-
    @@@neo4j
    @@@jolt
    @@@spel("${#content == null || #content == 'null' ? '[]' : #content }")
    @@@objectify(null, "screens")
    MATCH (s:COBOLScreen)
    OPTIONAL MATCH (s)-[:CONTAINS]->(p:COBOLParagraph)
    WITH s, COLLECT(DISTINCT p) AS paragraphs
    RETURN
      s.name AS name,
      s.rawCode AS rawCode,
      [p IN paragraphs WHERE p.name IS NOT NULL | {name: p.name, programName: p.programName}] AS listOfParagraphs
  paragraphVariables: |-
    @@@neo4j
    @@@jolt
    @@@spel("${#content == null || #content == 'null' ? '[]' : #content }")
    @@@objectify(null, "paragraphVariables")
    MATCH (cp:COBOLProgram)-[:CONTAINS]->(pd:COBOLProcedureDivision)-[:CONTAINS]->(p:COBOLParagraph)
    MATCH (cp)-[:CONTAINS]->(d:COBOLDataDivision)

    OPTIONAL MATCH (p)-[:CONTAINS]->(f:COBOLFileOperation)

    OPTIONAL MATCH (cp)-[:CONTAINS]->(d)-[:CONTAINS]->(section)-[:CONTAINS*]->(s)
    WHERE (s:Variable OR s:Structure) AND (s.name IN p.dataIdentifiers OR s.name IN f.rawCode)
    WITH p, f, s,
    CASE
         WHEN "COBOLLinkage" IN labels(s) THEN "linkage-variable"
         WHEN f.rawCode CONTAINS s.name THEN
           CASE WHEN f.operation = "READ" THEN "file-in" ELSE "file-out" END
         ELSE "variable"
    END
        AS fileType

    WHERE s.name IS NOT NULL

    RETURN
     p.programName        AS programName,
     id(p)                AS paragraphId,
     p.name               AS paragraphName,
     COLLECT(DISTINCT {
         name: s.name,
         type: fileType
     }) AS dataObjects
  joltNeo4jTableToJson: |-
    [
      {
        "operation": "shift",
        "spec": {
          "results": {
            "*": {
              "data": {
                "*": {
                  "row": {
                    "*": "[&2].@(4,columns[&0])"
                  }
                }
              }
            }
          }
        }
      }
    ]
  joltNeo4jSingleObjectsToJson: |-
    [
      {
        "operation": "shift",
        "spec": {
          "results": {
            "*": {
              "data": {
                "*": {
                  "row": {
                    "*": "[&2]"
                  }
                }
              }
            }
          }
        }
      }
    ]
  joltNeo4jUniqueObjectToJson: |-
    [
      {
        "operation": "shift",
        "spec": {
          "results": {
            "*": {
              "data": {
                "*": {
                  "row": {
                    "0": {
                      "*": "[]"
                    }
                  }
                }
              }
            }
          }
        }
      }
    ]
  programNames:
    COBOL: |-
      @@@neo4j
      @@@jolt
      MATCH (cp:COBOLProgram)
      RETURN COLLECT(cp.name)
  callgraph:
    COBOL: |-
      @@@freemarker
      <#compress>
      <#list programs?filter(it -> !$api.configs.options.splitByProgram || it.name == project.name) as program>
      ${program.name}: program.
      <#if program.identificationDivision??>IDENTIFICATION DIVISION: division.</#if>
      <#if program.environmentDivision??>ENVIRONMENT DIVISION: division.</#if>
      <#if program.dataDivision??>DATA DIVISION: division.</#if>
      <#if program.procedureDivision??>PROCEDURE DIVISION: division.
        <#list program.paragraphs as paragraph>
      ${paragraph.name}: paragraph. 
          <#list paragraph.calls as call>
          ${call.name}: call.
          <#list call.arguments as callArgument>
          ${callArgument}: call-variable.
          </#list>
          </#list>
          <#list paragraph.performs as perform>
      ${perform.name}: perform.
          </#list>
          <#if paragraphVariables?has_content><#assign paragraphWithVars = paragraphVariables?filter(it -> it.paragraphId == paragraph.id)>
             <#if paragraphWithVars?has_content && paragraphWithVars?first.dataObjects?has_content>
               <#list paragraphWithVars?first.dataObjects as dataObject>
      ${dataObject.name}: ${dataObject.type}.
               </#list>
             </#if>
          </#if>
        </#list>
      </#if>
      </#list>
      </#compress>
  tech:
    COBOL: |-
      @@@freemarker
      <#compress>
      <#function prettyJoin items delimiter valueWhenEmpty>
          <#if items??>
              <#if (items?size == 0)>
                  <#return valueWhenEmpty>
              <#elseif (items?size == 1)>
                  <#return items?first>
              <#else>
                  <#local subList = items[0..(items?size-2)]>
                  <#local lastItem = items[items?size - 1]>
                  <#return (subList?join(delimiter) + ' and ' + lastItem)>
              </#if>
          </#if>
      </#function>
      
      <#function writeContent reference>
          <#if $api.configs.options.byID>
              <#return 'content is given by the following id:\n<id> ' + (reference.id)?replace(",","")>
          <#else>
              <#return 'has the following content:\n' + reference.rawCode>
          </#if>
      </#function>
      
      <#function unique list>
          <#local uniqueMap = {}>
      
          <#list list as item>
              <#local uniqueMap = uniqueMap + {item: true}>
          </#list>
          <#return uniqueMap?keys>
      </#function>
      </#compress>
      
      The purpose of this document is to describe a code written in Cobol language. We need to fully understand the solution.
      
      JCL stands for Job Control Language. The purpose of JCL is to say which programs to run, using which files or devices for input or output, and at times to also indicate under what conditions to skip a step. Parameters in the JCL can also provide accounting information for tracking the resources used by a job as well as which machine the job should run on.
      
      The IDENTIFICATION DIVISION is one among the four divisions and should be the first division in COBOL program. It provides metadata about the program, such as its name, author, installation, and other descriptive information used to identify the program uniquely.
      
      The ENVIRONMENT DIVISION is primarily responsible for displaying the computer environment (mostly computer name in mainframe environment) on which the program is compiled and executed. In addition, it defines the input and output sources (files) required to run the program and interact with devices like printers, files, etc. Entire ENVIRONMENT DIVISION is optional and should be coded as a second division in the program immediately after IDENTIFICATION DIVISION if needed.
      
      Within the ENVIRONMENT DIVISION, the INPUT-OUTPUT SECTION specifies the file information that is useful to access the file in the program.
      
      The DATA DIVISION defines the variables that are used in the program for data processing. It represents the logical structure of the data, laying out how it is stored in memory. It is optional. However, each section in the DATA DIVISION has a specific logical function within the program. If sections are coded in the program, those should be coded in the same order shown in the syntax.
      
      Within the DATA DIVISION, a COBOL copybook is a section of code that defines the data structures of COBOL programs. Before writing your business rules, you identify the data structures on which you want to write and manage rules outside of your COBOL application.
      
      Within the DATA DIVISION, the FILE SECTION is a subsection of the DATA DIVISION. The record structure of the files should be declared in the FILE SECTION, and it contains all logical structures of the files that are used in the program. When we work with files (input files, output files, or both), the FILE SECTION helps us select the format these records should follow.
      
      Within the DATA DIVISION, LINKAGE SECTION is used to pass the data between COBOL programs and receive data from run JCL.
      
      The PROCEDURE DIVISION is one of the four main divisions of a COBOL program. It's where the program's logic is written and is responsible for carrying out the data processing tasks coded in the program. The PROCEDURE DIVISION consists of sections, paragraphs, sentences, and statements, which are the actual logic or operations to complete the task. Program execution starts from PROCEDURE DIVISION and ends with STOP RUN or GO BACK statements.
      
      <#if listOfJcls?has_content><#else>There is no JCL file in the cobol graph, therefore, each cobol program runs individually.</#if>
      
      <#list listOfJcls?filter(j -> !$api.configs.options.splitByProgram || j.programs?filter(it -> it.name == project.name)?has_content) as jcl>
      ${jcl.name} is a ${jcl.type} Jcl, which ${writeContent(jcl)}
      
      
      <#if jcl.programs?has_content>
      ${jcl.name} is a Jcl that invokes the Programs named: ${prettyJoin(jcl.programs?map(it -> it.name), ', ', 'none')}. There are no invocation to other processed FILEs.
      <#else>
      ${jcl.name} is a Jcl that does not invoke other processed FILEs.
      </#if>
      </#list>
      
      <#list programs?filter(it -> !$api.configs.options.splitByProgram || it.name == project.name) as program>
      <#assign listOfCallers = program.listOfParentJcl?map(it -> it.name + ' (JCL)') + program.listOfParentCobolProgram?map(it -> it.name + ' (COBOL Program)')>
      <#if listOfCallers?has_content>
      The program ${program.name} is invoked by: ${prettyJoin(listOfCallers, ', ', 'none')}.
      <#else>
      The program ${program.name} is not being invoked by a JCL neither a COBOL Program.
      </#if>
      
      <#compress>
      <#assign divisions = []>
      <#if program.identificationDivision?has_content> <#assign divisions += ['identification division']> </#if>
      <#if program.environmentDivision?has_content> <#assign divisions += ['environment division']> </#if>
      <#if program.dataDivision?has_content> <#assign divisions += ['data division']> </#if>
      <#if program.procedureDivision?has_content> <#assign divisions += ['procedure division']> </#if>
      </#compress>
      <#if (divisions?size > 0)>The program named ${program.name} contains the following divisions: ${prettyJoin(divisions, ', ', 'none')}.</#if>
      
      <#if program.identificationDivision??>
      The identification division from ${program.name} ${writeContent(program.identificationDivision)}
      </#if>  
      
      <#if program.environmentDivision?has_content>      
      The environment division from ${program.name} has the following Cobol components: InputOutputSection.
      <#if program.environmentDivision.inputOutputSection?has_content>
      The COBOL InputOutput section from ${program.name} has the following instructions: ${prettyJoin(program.environmentDivision.inputOutputSection?map(it -> it.name), ', ', 'none')}
      The InputOutput's section from ${program.name} ${writeContent(program.environmentDivision)}
      <#else>
      The COBOL InputOutput section from ${program.name} does not have any instructions.
      </#if>      
      </#if>      
      
      <#if program.dataDivision?has_content>
      <#assign dataDivisionComponents = []>
      <#if program.dataDivision.copyBooks?has_content><#assign dataDivisionComponents += ['Copybooks']></#if>
      <#if program.dataDivision.fileSection?has_content><#assign dataDivisionComponents += ['FileSection']></#if>
      <#if program.dataDivision.linkageSection?has_content><#assign dataDivisionComponents += ['LinkageSection']></#if>
      <#if program.dataDivision.workingStorageSection?has_content><#assign dataDivisionComponents += ['WorkingStorageSection']></#if>
      The data division from ${program.name} has the following Cobol components: ${prettyJoin(dataDivisionComponents, ', ', 'none')}
      <#list program.dataDivision.copyBooks as copybook>
      The copybook named ${copybook.name} from ${program.name} ${writeContent(copybook)}
      </#list>
      
      <#if program.dataDivision.fileSection?has_content>The COBOL File section from ${program.name} is comprised of the following files:
      <#list program.dataDivision.fileSection as fileDefinition>
       - ${fileDefinition.name} from ${program.name} ${writeContent(fileDefinition)}
      </#list>
      </#if>
      
      <#if program.dataDivision.linkageSection?has_content>This COBOL LinkageSection section is part of data division of the COBOL program named ${program.name}.
      The Linkage Section from ${program.name} ${writeContent(program.dataDivision.linkageSection)}
      </#if>
      
      <#if program.dataDivision.workingStorageSection?has_content>
      The WorkingStorage Section from ${program.name} ${writeContent(program.dataDivision.workingStorageSection)}
      </#if>
      </#if>
      
      <#if program.procedureDivision??>
      The procedure division is comprised of the following Cobol paragraphs: ${prettyJoin(program.paragraphs?map(it -> it.name), ', ', 'none')}.
      
      <#list program.procedureDivision.copyBooks as copybook>
      The copybook named ${copybook.name} from ${program.name} ${writeContent(copybook)}
      </#list>
      
      <#list program.paragraphs as paragraph>
      <#compress>
      <#assign paragraphRelations = []>
      <#if paragraph.calls?? && (paragraph.calls?size > 0)>
      <#assign paragraphRelations += ['calls the following external program in the program files ' + program.name + ': ' + prettyJoin(unique(paragraph.calls?map(it -> it.name)), ', ', '')]>
      </#if>
      
      <#if paragraph.performs?? && (paragraph.performs?size > 0)>
      <#assign paragraphRelations += ['performs the following paragraphs in the ' + program.name + ': ' + prettyJoin(unique(paragraph.performs?map(it -> it.name)), ', ', '')]>
      </#if>
      
      <#if paragraph.fileOperations?? && (paragraph.fileOperations?size > 0)>
      <#assign paragraphRelations += ['operates the following files in the program file ' + program.name + ': ' + prettyJoin(unique(paragraph.fileOperations?map(it -> it.name)), ', ', '')]>
      </#if>
      
      <#if paragraph.execSqlStatement?? && (paragraph.execSqlStatement?size > 0)>
      <#assign paragraphRelations += ['runs the following SQL Statements in the program file ' + program.name + ': ' + prettyJoin(unique(paragraph.execSqlStatement?map(it -> it.sqlClause + ' over the tables: ' + prettyJoin(it.db2TableList?map(it2 -> it2.name), ', ', 'none'))), ', ', '')]>
      </#if>
      </#compress>
      The Paragraph named ${paragraph.name} ${prettyJoin(paragraphRelations, '; ', 'does not contain any other mapped object')}.
      ${paragraph.name} ${writeContent(paragraph)}
      
      </#list>
      </#if>
      </#list>
      
      <#if screens??>
      <#list screens?filter(scr -> !$api.configs.options.splitByProgram || (scr.listOfParagraphs?has_content && scr.listOfParagraphs?filter(scrPar -> scrPar.programName == project.name)?has_content)) as screen>
      The following CICS Map is present: ${screen.name}
      ${screen.name} ${writeContent(screen)}
      
      </#list>
      </#if>
      
      ==============TRANSCRIPTION END=============