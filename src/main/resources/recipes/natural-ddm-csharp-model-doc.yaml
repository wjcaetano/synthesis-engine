config:
  fresh: true
  transformDefaultParams:
    jolt:
      - "${#recipe['templates']['joltNeo4jTableToJson']}"
    neo4j:
      - "${@Utils.getEnvVariable('NEO4J_API_URI')}"
      - "${@Utils.createBasicAuthHeader(@Utils.getEnvVariable('NEO4J_USERNAME'), @Utils.getEnvVariable('NEO4J_PASSWORD'))}"
executor: ProjectModelExecutor2.java
projectsReference:
  - name: test
projectModel:
  ddms.json: "${#recipe['templates']['ddms']}"
  csharpModelClasses.json: "${#recipe['templates']['csharpModelClasses']}"
  #classifyDdms: "${#recipe['templates']['classifyDdms']}"
  ddmsEnriching.json: "${#recipe['templates']['ddmsEnriching']}"
  final.html: "${#recipe['templates']['html']}"
templates:
  joltNeo4jTableToJson: |-
    [
      {
        "operation": "shift",
        "spec": {
          "results": {
            "*": {
              "data": {
                "*": {
                  "row": {
                    "*": "[&2].@(4,columns[&0])"
                  }
                }
              }
            }
          }
        }
      }
    ]
  ddms: |-
    @@@freemarker
    @@@neo4j
    @@@jolt
    @@@set("ddms")
    MATCH (ddm:NaturalDefineDataModule)-[:CONTAINS]->(nvar:NaturalVariable)
    RETURN
      nvar.name     AS name,
      ddm.rawCode   AS rawCode
    <#if $api.configs.options.singleItems == true>LIMIT 1</#if>
  csharpModelClasses: |-
    @@@freemarker
    @@@spel("${@FileUtils.zipToMapOfStrings(#content, false)}")
    @@@set("mapOfModels")
    @@@jsonify
    ${$api['files']['models.zip']}
  classifyDdms: |-
    @@@freemarker
    @@@prompt
    @@@extractMarkdownCode
    @@@objectify
    @@@_set("classifiedDdms")
    Given the list of DDMs below and the respective rawCode of them, and also the list of C# Model Classes and respective Code, classify
    each of DDM object to it's equivalent version in C#.
    
    You should answer with a single JSON Object following the [TEMPLATE], where each entry will associate a ddmName with the 
    respective C# Model File Name with Extension
    {
      "ddmName": "cSharpModelFileName",
      ...
    }
    
    [DDMS]
    <#list ddms as ddm>
    [DDM]
    DDM name: ${ddm.name}
    DDM rawCode:
    ${ddm.rawCode}
    [/DDM]
    -----------------------------
    </#list>
    
    [C# MODEL CLASSES]
    <#list mapOfModels as k, v>
    [MODEL]
    C# Model Class File Name: ${k}
    C# Model Class Content:
    ${v}
    [/MODEL]
    -----------------------------
    </#list>
  ddmsEnriching: |-
    @@@repeat("${#ddms}", "ddm", "${#recipe['templates']['ddmEnriching']}")
    @@@get("ddms")
    @@@jsonify
  ddmEnriching: |-
    @@@default("FAILED")
    @@@log("${'DDM Enriching: ' + #ddm['name']}")
    @@@_spel("${#mapOfModels[(#classifiedDdms[(#ddm['name'])])]}")
    @@@freemarker
    @@@prompt
    @@@extractMarkdownCode
    @@@objectify
    @@@set("ddm.fields")
    Seguindo o [TEMPLATE] e o [EXAMPLE] abaixo, realize o que é necessário para os códigos atuais de [DDM] vs [C# MODEL CLASS].
    
    **Objetivo:** Gerar uma comparação de um Data Definition Module [DDM] com sua correspondente [C# MODEL CLASS], apresentada em formato JSON.
    
    **Informações Principais a Fornecer:**
    1.  **Estrutura do DDM:**
    ```
    DEFINE DATA LOCAL
    1 PERSON-DATA VIEW OF PERSON-DATA
    2 PERSON-ID       N0005N
    2 PERSON-NAME     A0020N
    2 PERSON-DOB      N0008N
    END-DEFINE
    ```
    2.  **Classe de Modelo C#:**
    ```csharp
    public class PersonData
    {
    public int PersonId { get; set; } // Corresponde a PERSON-ID (N0005N)
    public string PersonName { get; set; } // Corresponde a PERSON-NAME (A0020N)
    public DateOnly? DateOfBirth { get; set; } // Corresponde a PERSON-DOB (N0008N)
    }
    ```
    
    **Formato de Saída:**
    *   Array JSON de objetos.
    *   Cada objeto representa um mapeamento campo/propriedade.
    *   Cada objeto deve ter as seguintes chaves:
    *   `DDMFieldName`: O nome do campo no DDM.
    *   `DDMTypeLength`: As informações de tipo e tamanho do DDM.
    *   `C#PropertyName`: O nome da propriedade correspondente na classe C#.
    *   `C#Type`: O tipo de dado da propriedade na classe C#.
    *   `Notes`: Uma breve descrição do mapeamento (por exemplo, "Correspondência", "Promoção de tipo", "Conversão de tipo - Data", "Anulável", etc.).
    
    **Instruções para a IA:**
    *   Analise as definições fornecidas do DDM e da classe de modelo C#.
    *   Identifique os campos e propriedades correspondentes com base em convenções de nomenclatura e tipos de dados.
    *   Para cada campo do DDM, determine sua propriedade correspondente em C#. Se não houver correspondência direta, infira o mapeamento mais provável.
    *   Registre quaisquer conversões ou promoções de tipo necessárias (por exemplo, COBOL `PIC N` para C# `int` ou `long`, COBOL `PIC A(8)` YYYYMMDD para C# `DateOnly?`, COBOL `PIC A(1)` para C# `char?`).
    *   Se um campo do DDM não tiver propriedade correspondente em C#, ou vice-versa, registre isso.
    *   Estruture a saída como um array JSON de objetos, conforme especificado acima.
    *   Garanta que o JSON esteja bem formatado.
    
    
    **[TEMPLATE] da estrutura JSON desejada por entrada:**
    
    [TEMPLATE]
    {
      "DDMFieldName": "SAMPLE-FIELD-NAME",
      "DDMTypeLength": "A0010N",
      "C#PropertyName": "SampleFieldName",
      "C#Type": "string",
      "Notes": "Correspondência"
    }
    
    [EXAMPLE]
    [
      {
        "DDMFieldName": "PES-ESTAGIARIO",
        "DDMTypeLength": "VIEW OF",
        "C#PropertyName": null,
        "C#Type": null,
        "Notes": "Nome da estrutura raiz"
      },
      {
        "DDMFieldName": "EST-TR",
        "DDMTypeLength": "A0010N",
        "C#PropertyName": "RbEstTr",
        "C#Type": "string",
        "Notes": "Correspondência"
      },
      ...
    ]
    
    [DDM]
    ${ddm.rawCode}
    
    [C# MODEL CLASS]
    ${mapOfModels[(classifiedDdms[(ddm.name)])]}
  modelsEnriching: |-
    @@@repeat("${#mapOfModels}", "model", "${#recipe['templates']['modelEnriching']}")
    @@@get("models")
    @@@jsonify
  modelEnriching: |-
    @@@_spel("${#models[].name")
    @@@default("FAILED")
    @@@log("${'Model Enriching: ' + #mapOfModels['name']}")
    @@@freemarker
    @@@prompt
    @@@extractMarkdownCode
    @@@objectify
    @@@set("ddm.fields")
    Seguindo o [TEMPLATE] e o [EXAMPLE] abaixo, realize o que é necessário para os códigos atuais de [DDM] vs [C# MODEL CLASS].
    
    **Objetivo:** Gerar uma comparação de um Data Definition Module [DDM] com sua correspondente [C# MODEL CLASS], apresentada em formato JSON.
    
    **Informações Principais a Fornecer:**
    1.  **Estrutura do DDM:**
    ```
    DEFINE DATA LOCAL
    1 PERSON-DATA VIEW OF PERSON-DATA
    2 PERSON-ID       N0005N
    2 PERSON-NAME     A0020N
    2 PERSON-DOB      N0008N
    END-DEFINE
    ```
    2.  **Classe de Modelo C#:**
    ```csharp
    public class PersonData
    {
    public int PersonId { get; set; } // Corresponde a PERSON-ID (N0005N)
    public string PersonName { get; set; } // Corresponde a PERSON-NAME (A0020N)
    public DateOnly? DateOfBirth { get; set; } // Corresponde a PERSON-DOB (N0008N)
    }
    ```
    
    **Formato de Saída:**
    *   Array JSON de objetos.
    *   Cada objeto representa um mapeamento campo/propriedade.
    *   Cada objeto deve ter as seguintes chaves:
    *   `DDMFieldName`: O nome do campo no DDM.
    *   `DDMTypeLength`: As informações de tipo e tamanho do DDM.
    *   `C#PropertyName`: O nome da propriedade correspondente na classe C#.
    *   `C#Type`: O tipo de dado da propriedade na classe C#.
    *   `Notes`: Uma breve descrição do mapeamento (por exemplo, "Correspondência", "Promoção de tipo", "Conversão de tipo - Data", "Anulável", etc.).
    
    **Instruções para a IA:**
    *   Analise as definições fornecidas do DDM e da classe de modelo C#.
    *   Identifique os campos e propriedades correspondentes com base em convenções de nomenclatura e tipos de dados.
    *   Para cada campo do DDM, determine sua propriedade correspondente em C#. Se não houver correspondência direta, infira o mapeamento mais provável.
    *   Registre quaisquer conversões ou promoções de tipo necessárias (por exemplo, COBOL `PIC N` para C# `int` ou `long`, COBOL `PIC A(8)` YYYYMMDD para C# `DateOnly?`, COBOL `PIC A(1)` para C# `char?`).
    *   Se um campo do DDM não tiver propriedade correspondente em C#, ou vice-versa, registre isso.
    *   Estruture a saída como um array JSON de objetos, conforme especificado acima.
    *   Garanta que o JSON esteja bem formatado.
    
    
    **[TEMPLATE] da estrutura JSON desejada por entrada:**
    
    [TEMPLATE]
    {
      "DDMFieldName": "SAMPLE-FIELD-NAME",
      "DDMTypeLength": "A0010N",
      "C#PropertyName": "SampleFieldName",
      "C#Type": "string",
      "Notes": "Correspondência"
    }
    
    [EXAMPLE]
    [
      {
        "DDMFieldName": "PES-ESTAGIARIO",
        "DDMTypeLength": "VIEW OF",
        "C#PropertyName": null,
        "C#Type": null,
        "Notes": "Nome da estrutura raiz"
      },
      {
        "DDMFieldName": "EST-TR",
        "DDMTypeLength": "A0010N",
        "C#PropertyName": "RbEstTr",
        "C#Type": "string",
        "Notes": "Correspondência"
      },
      ...
    ]
    
    [DDM]
    ${ddm.rawCode}
    
    [C# MODEL CLASS]
    ${mapOfModels[(classifiedDdms[(ddm.name)])]}
  html: |-
    @@@freemarker
    <!DOCTYPE html>
    <html lang="pt-br">
    <head>
      <meta charset="utf-8" />
      <title>Comparativo DDM × C# Model</title>
      <meta name="viewport" content="width=device-width,initial-scale=1" />
      <style>
    	:root {
    	  --bg: #0b0f14;
    	  --panel: #10151c;
    	  --muted: #9aa4b2;
    	  --txt: #e6edf3;
    	  --border: #202b3a;
    	  --ok: rgba(16,185,129,.12);
    	  --warn: rgba(245,158,11,.12);
    	  --miss: rgba(239,68,68,.12);
    	}
    	html, body { background: var(--bg); color: var(--txt); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif; line-height: 1.45; }
    	body { margin: 24px; }
    	h1 { font-size: 1.6rem; margin: 0 0 16px; }
    	h2 { font-size: 1.25rem; margin: 28px 0 12px; }
    	.muted { color: var(--muted); }
    	.ddm { background: var(--panel); border: 1px solid var(--border); border-radius: 12px; padding: 16px; margin-bottom: 20px; }
    	details { margin: 8px 0 14px; }
    	summary { cursor: pointer; color: var(--muted); }
    	pre { background: #0a0e13; border: 1px solid var(--border); border-radius: 8px; padding: 12px; overflow: auto; }
    	table { width: 100%; border-collapse: collapse; border: 1px solid var(--border); border-radius: 10px; overflow: hidden; }
    	thead th { background: #0f1620; text-align: left; padding: 10px; font-weight: 600; border-bottom: 1px solid var(--border); }
    	tbody td { padding: 10px; border-bottom: 1px solid var(--border); vertical-align: top; }
    	tbody tr:nth-child(even) td { background: rgba(255,255,255,0.01); }
    	code { background: #0a0e13; padding: 2px 6px; border: 1px solid var(--border); border-radius: 6px; }
    	.ok td { background: var(--ok); }
    	.warn td { background: var(--warn); }
    	.missing td { background: var(--miss); }
    	.tag { display: inline-block; font-size: .75rem; padding: 2px 8px; border: 1px solid var(--border); border-radius: 999px; color: var(--muted); }
      </style>
    </head>
    <body>
      <h1>Comparativo DDM × C# Model</h1>
    
      <#if ddms?? && (ddms?size > 0)>
    	<#list ddms as ddm>
    	  <section class="ddm">
    		<h2 id="${(ddm.name!'')?url}">${(ddm.name!'(sem nome)')?html}</h2>
    
    		<p class="muted">
    		  <span class="tag">Total campos: ${ddm.fields???then(ddm.fields?size, 0)}</span>
    		</p>
    
    		<details>
    		  <summary>Ver código bruto do DDM</summary>
    		  <pre>${(ddm.rawCode!'')?html}</pre>
    		</details>
    
    		<#if ddm.fields?? && (ddm.fields?size > 0)>
    		  <table>
    			<thead>
    			  <tr>
    				<th>Campo DDM</th>
    				<th>Tipo/Tamanho DDM</th>
    				<th>Propriedade C#</th>
    				<th>Tipo C#</th>
    				<th>Notas</th>
    			  </tr>
    			</thead>
    			<tbody>
    			  <#list ddm.fields as field>
    				<#-- Preparar valores e classes -->
    				<#assign ddmField = (field.DDMFieldName!'')?string?html />
    				<#assign ddmType  = (field.DDMTypeLength!'')?string?html />
    				<#assign csName   = (field['C#PropertyName']!'')?string />
    				<#assign csType   = (field['C#Type']!'')?string />
    				<#assign notes    = (field.Notes!'')?string />
    
    				<#assign noteLc = notes?lower_case />
    				<#assign rowClass = '' />
    				<#if (csName?length == 0)>
    				  <#assign rowClass = 'missing' />
    				<#elseif noteLc?contains('correspond')>
    				  <#assign rowClass = 'ok' />
    				<#elseif noteLc?matches('.*(convers|promo|data|date|null|anul).*')>
    				  <#assign rowClass = 'warn' />
    				</#if>
    
    				<tr class="${rowClass}">
    				  <td>${ddmField}</td>
    				  <td><code>${ddmType}</code></td>
    				  <td>${csName?html}</td>
    				  <td><code>${csType?html}</code></td>
    				  <td>${notes?html}</td>
    				</tr>
    			  </#list>
    			</tbody>
    		  </table>
    		<#else>
    		  <p class="muted">Sem mapeamentos gerados para este DDM.</p>
    		</#if>
    	  </section>
    	</#list>
      <#else>
    	<p class="muted">Nenhum DDM disponível no contexto.</p>
      </#if>
    </body>
    </html>