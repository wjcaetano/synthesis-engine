config:
  agents:
    - name: AZURE
      temperature: 0.3
    - name: BEDROCK
      temperature: 0.4
  fresh: true
  transformDefaultParams:
    jolt:
      - "${#recipe['templates']['joltNeo4jTableToHeadersAndRows']}"
    neo4j:
      - "${@Utils.getEnvVariable('NEO4J_API_URI')}"
      - "${@Utils.createBasicAuthHeader(@Utils.getEnvVariable('NEO4J_USERNAME'), @Utils.getEnvVariable('NEO4J_PASSWORD'))}"
  options:
    - name: splitByProgram
      type: BOOLEAN
      label: "Split By Program"
      defaultValue: false
  progressCustomData: "${#projects != null ? #projects[0]['reports'] : null}"
executor: ProjectModelExecutor3.java
scripts:
  ReportBeforeAll:
    type: GROOVY
    body: |
      import com.capco.brsp.synthesisengine.service.*
      import com.capco.brsp.synthesisengine.utils.*
      import org.springframework.context.ApplicationContext
      class ReportBeforeAll implements IExecutor {
        Object execute(ApplicationContext applicationContext, Map<String, Object> projectContext) {
          def contextService = applicationContext.getBean(ContextService.class)
          def projectUUID = contextService.getProjectContext().get("projectUUID") as UUID
          def tempOriginalProjectsContent = Utils.decodeBase64ToString(Objects.requireNonNull(projectContext['$api'].files['monolith_decomposition_report.json'], "File 'monolith_decomposition_report.json' is missing!") as String)
          def monolithDecompositionReport = tempOriginalProjectsContent instanceof List ? tempOriginalProjectsContent : JsonUtils.readAsList(tempOriginalProjectsContent)
          projectContext['$api'].files.clusters = monolithDecompositionReport
      
          final def projects = projectContext.compute('projects', (k, v) -> new ConcurrentLinkedList<>()) as ConcurrentLinkedList
          final def project = new ConcurrentLinkedHashMap<>()
          project.name = "reports"
          projects.add(project)
      
          projectContext.put('project', project)
      
          def templates = projectContext.recipe.templates as Map<String, Object>
          def reportsTemplates = templates.reports as List<Map<String, Object>>
          project.reports = Utils.convertToConcurrent(templates.cards as List<Map<String, Object>>)
          project.cardsFilesMap = Utils.convertToConcurrent(
            project.reports.collectEntries { it -> [(it.name): reportsTemplates[Integer.valueOf(it.id as String)].entrySet().first().getValue()] }
          )
          return "OK"
        }
      }
projectsReference:
  - name: reports
projectModel:
  _beforeAll: |
    @@@script('ReportBeforeAll')
    // Skipped/Empty File
  _contextReports: |
    ${#recipe['templates']['reportCopy']}
    // Skipped/Empty File
  _contextCards: |
    ${#recipe['templates']['cardFilesMap']}
    // Skipped/Empty File
  _contextFlows: |
    ${#recipe['templates']['flowCallgraphCypherQuery']}
    // Skipped/Empty File
  _contextIos: |
    ${#recipe['templates']['ioCallgraphCypherQuery']}
    // Skipped/Empty File

  context/screensAsciiView: "${#screens != null ? @Utils.createWithAListOfKeys(#screens.![#this['screenName']], #recipe['templates']['screenAsciiView']) : {}}"
  context/screensBusinessLogic: "${#screens != null ? @Utils.createWithAListOfKeys(#screens.![#this['screenName']], #recipe['templates']['screenBusinessLogic']) : {}}"
  cards: "$${#project['cardsFilesMap']}"
vars:
  neo4jURL: "http://localhost:7474/db/neo4j/tx/commit"
  neo4jEncodedAuth: "Basic bmVvNGo6c2VsZWN0LXNoaXJ0LWp1ZGdlLW1pZ3VlbC1hbnRvbmlvLTQ2"
templates:
  reportCopy: |-
    @@@_spel("${#project.put('reports', #recipe['templates']['cards'])}")
    OK
  cardFilesMap: |-
    @@@freemarker
    @@@set('project.cardsFilesMap')
    {
    <#list recipe.templates.cards as report>
        "${report.name}": "${recipe.templates.reports[report.id?number]?values[0]?json_string}"<#if report_has_next>,</#if>
    </#list>
    }
  cards:
    [
      {
        "id": "0",
        "name": "Files Report",
        "description": "Number of files for different components.",
        "type": "table"
      },
      {
        "id": "1",
        "name": "File Content Report",
        "description": "Number of JCL, Cobol, DB2, Store Procedure, VSAM, Files and Screens available.",
        "type": "table"
      },
      {
        "id": "2",
        "name": "Connectivity to Data Tables",
        "description": "Paragraphs usage of Data Tables and Store Procedures.",
        "type": "table"
      },
      {
        "id": "3",
        "name": "Components Diagram",
        "description": "Components and Sub-Components diagrams.",
        "type": "table"
      },
      {
        "id": "4",
        "name": "Cyclomatic Complexity",
        "description": "Number of nodes, edges and the estimated cyclomatic complexity per paragraph.",
        "type": "table-heatmap"
      },
      {
        "id": "5",
        "name": "Halstead Index (Maintainability)",
        "description": "Measures the maintainability level for each program.",
        "type": "table"
      },
      {
        "id": "6",
        "name": "JCL Statistics",
        "description": "What happens inside the JCLs.",
        "type": "table"
      },
      {
        "id": "7",
        "name": "Paragraphs Usage",
        "description": "Check how many times any given paragraph is referenced by other code paragraphs. If it's zero it is either a main paragraph or possibly a dead piece of code.",
        "type": "table"
      },
      {
        "id": "8",
        "name": "GO TO Analysis",
        "description": "Count the number of GO TO paths.",
        "type": "table"
      },
      {
        "id": "9",
        "name": "Missing Inventory",
        "description": "Check references to missing code or files.",
        "type": "table"
      },
      {
        "id": "10",
        "name": "Dead Code",
        "description": "Check if there any element declared but never used.",
        "type": "table"
      },
      {
        "id": "11",
        "name": "Dead Code Metadata",
        "description": "Check if there are paragraphs declared but never used, with metadata.",
        "type": "table"
      },
      {
        "id": "12",
        "name": "MIPS Complexity",
        "description": "Million Instructions Per Second Report",
        "type": "table-heatmap"
      },
      {
        "id": "13",
        "name": "Callgraph Flow",
        "description": "Callgraph flow diagram that shows the relationships between COBOL programs, paragraphs and their components.",
        "type": "plantuml"
      },
      {
        "id": "14",
        "name": "Blueprint Flow",
        "description": "Blueprint flow diagram that shows the generated structure of the forward engineering application.",
        "type": "plantuml"
      },
      {
        "id": "15",
        "name": "Screen Documentation and Flow Analysis",
        "description": "A comprehensive documentation interface that displays COBOL screen layouts, their ASCII representations, and program flow analysis through call graphs.",
        "type": "html"
      },
      {
        "id": "16",
        "name": "PlantUML Mock",
        "description": "Human Lifecycle",
        "type": "plantuml"
      },
      {
        "id": "17",
        "name": "Component Diagram",
        "description": "Visualize the high-level components of the system and their relationships and provides a bird's-eye view of the system architecture.",
        "type": "plantuml"
      },
      {
        "id": "18",
        "name": "JCL Processing Flow",
        "description": "JCL processing flow diagram that shows the relationships between JCLs, COBOL programs, and their components.",
        "type": "plantuml"
      }
    ]
  reports:
    - filesReport: |-
        @@@neo4j
        @@@jolt
        @@@set('reports[0]')
        @@@jsonify
        MATCH (n)
        WHERE n:COBOLJcl OR n:COBOLProgram OR n:Db2Table OR n:Db2Procedure OR n:Screen OR n:COBOLVsamFile or n:COBOLFileControl
        WITH 
          sum(CASE WHEN n:COBOLJcl THEN 1 ELSE 0 END) as Jcl_ProcCount,
          sum(CASE WHEN n:COBOLProgram THEN 1 ELSE 0 END) as ProgramCount,
          sum(CASE WHEN n:Db2Table THEN 1 ELSE 0 END) as TableCount,
          sum(CASE WHEN n:Db2Procedure THEN 1 ELSE 0 END) as StoredProcCount,
          sum(CASE WHEN n:COBOLVsamFile THEN 1 ELSE 0 END) as VSMCount,
          sum(CASE WHEN n:COBOLFileControl THEN 1 ELSE 0 END) as FileCtrCount,
          sum(CASE WHEN n:Screen THEN 1 ELSE 0 END) as ScrCount
        RETURN 
          Jcl_ProcCount as NumberOfJCLsOrProcs,
          ProgramCount as NumberOfCobolPrograms,
          TableCount as NumberOfDB2Tables,
          StoredProcCount as StoredProcedureCount,
          VSMCount as VSAMCount,
          FileCtrCount as FileCount,
          ScrCount as ScreenCount
    - fileContentReport: |-
        @@@neo4j
        @@@jolt
        @@@set('reports[1]')
        @@@jsonify
        MATCH (prog:COBOLProgram)
        OPTIONAL MATCH (prog)-[:CONTAINS]->(proc:COBOLProcedureDivision)-[:CONTAINS]->(para:COBOLParagraph)
        WITH prog, COLLECT(para.rawCode) as logicCodes, count(para) as paragraphCount
        OPTIONAL MATCH (prog)-[:CONTAINS]->(data:COBOLDataDivision)
        WITH prog, logicCodes, paragraphCount, data.rawCode as dataCode
        WITH prog,
            logicCodes,
            paragraphCount,
            CASE WHEN dataCode IS NOT NULL THEN size(split(dataCode, '\n')) ELSE 0 END as dataLines
        UNWIND logicCodes as logic
        WITH 
           prog.name AS programName,
           sum(size(split(coalesce(logic, ''), '\n'))) as totalLinesLogic,
           dataLines as totalLinesData,
           sum(size(split(coalesce(logic, ''), '\n'))) + dataLines as grandTotal,
           paragraphCount,
           ROUND(1.0 * sum(size(split(coalesce(logic, ''), '\n'))) / paragraphCount, 1) as avgLinesPerParagraph,
           ROUND(1.0 * dataLines / sum(size(split(coalesce(logic, ''), '\n'))), 2) as dataToLogicRatio
        RETURN 
           programName,
           totalLinesLogic,
           totalLinesData,
           grandTotal,
           paragraphCount,
           avgLinesPerParagraph,
           dataToLogicRatio,
           CASE 
               WHEN dataToLogicRatio > 1.5 THEN 'Data-Heavy'
               WHEN dataToLogicRatio < 0.5 THEN 'Logic-Heavy'
               ELSE 'Balanced'
           END as dataLogicProfile,
           CASE 
               WHEN avgLinesPerParagraph > 50 THEN 'Complex'
               WHEN avgLinesPerParagraph > 30 THEN 'Moderate'
               ELSE 'Simple'
           END as complexityProfile,
           CASE
               WHEN paragraphCount > 50 THEN 'Large'
               WHEN paragraphCount > 25 THEN 'Medium'
               ELSE 'Small'
           END as sizeProfile,
           CASE 
               WHEN avgLinesPerParagraph > 50 AND paragraphCount > 50 THEN 'High Risk'
               WHEN avgLinesPerParagraph > 30 OR paragraphCount > 50 THEN 'Medium Risk'
               ELSE 'Low Risk'
           END as maintenanceRisk
        ORDER BY grandTotal DESC
    - connectivityToDataTables: |-
        @@@neo4j
        @@@jolt
        @@@set('reports[2]')
        @@@jsonify
        MATCH (p:COBOLParagraph)
        RETURN 
          apoc.text.regexGroups(p.filePath, ".*[\\\\/](.*)$")[0][1] AS fileName, p.name AS Paragraph,
  
          // Count of COBOLExecSqlStatement connected to Db2Table
          size([
            (p)-[:CONTAINS]->(:COBOLExecSqlStatement)-[:CONTAINS]->(:Db2Table) 
            | 1
          ]) AS ExecSqlStatementCount,
        
          // Count of Db2Procedure connected via COBOLExecSqlStatement
          size([
            (p)-[:CONTAINS]->(:COBOLExecSqlStatement)-[:CONTAINS]->(:Db2Procedure) 
            | 1
          ]) AS Db2ProcedureCount,
        
          // Count of COBOLExecSqlStatement not connected to Db2Table or Db2Procedure
          size([
            (p)-[:CONTAINS]->(s:COBOLExecSqlStatement) 
            WHERE NOT (
              (s)-[:CONTAINS]->(:Db2Table) 
              OR 
              (s)-[:CONTAINS]->(:Db2Procedure)
            )
            | 1
          ]) AS HangingExecSqlStatementCount
        ORDER BY p.name
    - componentsDiagram: |-
        @@@neo4j
        @@@jolt
        @@@set('reports[3]')
        @@@jsonify
        // Part 1: COBOLProgram starting points
        MATCH (program:COBOLProgram)
        OPTIONAL MATCH (program)-[r1]-(otherProgram:COBOLProgram)
        OPTIONAL MATCH (jcl:COBOLJcl)-[r2]-(program)
        OPTIONAL MATCH (program)-[r3]-(procDiv:COBOLProcedureDivision)
        OPTIONAL MATCH (procDiv)-[r4]-(paragraph:COBOLParagraph)
        WHERE
        EXISTS { MATCH (paragraph)-[:CONNECTS_TO]-(sql0:COBOLExecSqlStatement) }
        OR paragraph.rawCode CONTAINS 'CALL '
        OR paragraph.rawCode CONTAINS 'PERFORM '
        OR paragraph.rawCode CONTAINS 'GO TO '
        OPTIONAL MATCH (paragraph)-[r5]-(sql1:COBOLExecSqlStatement)
        OPTIONAL MATCH (sql1)-[r6]-(db2Table1:Db2Table)
        OPTIONAL MATCH (sql1)-[r7]-(db2Proc:Db2Procedure)
        OPTIONAL MATCH (db2Proc)-[r8]-(sql2:COBOLExecSqlStatement)
        OPTIONAL MATCH (sql2)-[r9]-(db2Table2:Db2Table)
        OPTIONAL MATCH (paragraph)-[r10]-(perform:COBOLPerform)
        RETURN
            'COBOLProgram'                                      AS sourceType,
            id(program)                                         AS programId,
            program.name                                        AS programName,
            apoc.text.regexGroups(program.filePath,
                  '.*\\\\[0-9A-Fa-f\\-]{36}\\\\(.+)$')[0][1]    AS programRelativeFilePath,
            id(otherProgram)                                    AS connectedNodeId,
            otherProgram.name                                   AS connectedNodeName,
            apoc.text.regexGroups(otherProgram.filePath,
                    '.*\\\\[0-9A-Fa-f\\-]{36}\\\\(.+)$')[0][1]  AS connectedNodeRelativeFilePath,
            id(r1)                                              AS relProgramConnectedId,
            type(r1)                                            AS relProgramConnectedType,
            id(jcl)                                             AS jclId,
            jcl.name                                            AS jclName,
            apoc.text.regexGroups(jcl.filePath,
                  '.*\\\\[0-9A-Fa-f\\-]{36}\\\\(.+)$')[0][1]    AS jclRelativeFilePath,
            id(r2)                                              AS relJclProgramId,
            type(r2)                                            AS relJclProgramType,
            id(procDiv)                                         AS procDivId,
            'Procedure Division of ' +
            apoc.text.regexGroups(procDiv.filePath,'^.*/(.+)$')[0][1] AS procDivName,
            apoc.text.regexGroups(procDiv.filePath,
                  '.*\\\\[0-9A-Fa-f\\-]{36}\\\\(.+)$')[0][1]    AS procDivRelativeFilePath,
            id(r3)                                              AS relProgramToProcDivId,
            type(r3)                                            AS relProgramToProcDivType,
            id(paragraph)                                       AS paragraphId,
            paragraph.name                                      AS paragraphName,
            apoc.text.regexGroups(paragraph.filePath,
                  '.*\\\\[0-9A-Fa-f\\-]{36}\\\\(.+)$')[0][1]    AS paragraphRelativeFilePath,
            id(r4)                                              AS relProcDivToParagraphId,
            type(r4)                                            AS relProcDivToParagraphType,
            id(sql1)                                            AS sqlStmt1Id,
            sql1.name                                           AS sqlStmt1Name,
            apoc.text.regexGroups(sql1.filePath,
                  '.*\\\\[0-9A-Fa-f\\-]{36}\\\\(.+)$')[0][1]    AS sqlStmt1RelativeFilePath,
            id(r5)                                              AS relParagraphToSql1Id,
            type(r5)                                            AS relParagraphToSql1Type,
            id(db2Table1)                                       AS db2Table1Id,
            db2Table1.name                                      AS db2Table1Name,
            apoc.text.regexGroups(db2Table1.filePath,
                  '.*\\\\[0-9A-Fa-f\\-]{36}\\\\(.+)$')[0][1]    AS db2Table1RelativeFilePath,
            id(r6)                                              AS relSql1ToDb2Table1Id,
            type(r6)                                            AS relSql1ToDb2Table1Type,
            id(db2Proc)                                         AS db2ProcId,
            db2Proc.name                                        AS db2ProcName,
            apoc.text.regexGroups(db2Proc.filePath,
                  '.*\\\\[0-9A-Fa-f\\-]{36}\\\\(.+)$')[0][1]    AS db2ProcRelativeFilePath,
            id(r7)                                              AS relSql1ToDb2ProcId,
            type(r7)                                            AS relSql1ToDb2ProcType,
            id(sql2)                                            AS sqlStmt2Id,
            sql2.name                                           AS sqlStmt2Name,
            apoc.text.regexGroups(sql2.filePath,
                  '.*\\\\[0-9A-Fa-f\\-]{36}\\\\(.+)$')[0][1]    AS sqlStmt2RelativeFilePath,
            id(r8)                                              AS relDb2ProcToSql2Id,
            type(r8)                                            AS relDb2ProcToSql2Type,
            id(db2Table2)                                       AS db2Table2Id,
            db2Table2.name                                      AS db2Table2Name,
            apoc.text.regexGroups(db2Table2.filePath,
                  '.*\\\\[0-9A-Fa-f\\-]{36}\\\\(.+)$')[0][1]    AS db2Table2RelativeFilePath,
            id(r9)                                              AS relSql2ToDb2Table2Id,
            type(r9)                                            AS relSql2ToDb2Table2Type,
            id(perform)                                         AS performId,
            perform.name                                        AS performName,
            apoc.text.regexGroups(perform.filePath,
                  '.*\\\\[0-9A-Fa-f\\-]{36}\\\\(.+)$')[0][1]    AS performRelativeFilePath,
            id(r10)                                             AS relParagraphToPerformId,
            type(r10)                                           AS relParagraphToPerformType
        
        UNION
        
        // Part 2: COBOLJcl starting points (aliases *must* match above)
        MATCH (jcl:COBOLJcl)
        OPTIONAL MATCH (jcl)-[r1]-(otherJcl:COBOLJcl)
        OPTIONAL MATCH (program:COBOLProgram)-[r2]-(jcl)
        OPTIONAL MATCH (program)-[r3]-(procDiv:COBOLProcedureDivision)
        OPTIONAL MATCH (procDiv)-[r4]-(paragraph:COBOLParagraph)
        WHERE
        EXISTS { MATCH (paragraph)-[:CONNECTS_TO]-(sql0:COBOLExecSqlStatement) }
        OR paragraph.rawCode CONTAINS 'CALL '
        OR paragraph.rawCode CONTAINS 'PERFORM '
        OR paragraph.rawCode CONTAINS 'GO TO '
        OPTIONAL MATCH (paragraph)-[r5]-(sql1:COBOLExecSqlStatement)
        OPTIONAL MATCH (sql1)-[r6]-(db2Table1:Db2Table)
        OPTIONAL MATCH (sql1)-[r7]-(db2Proc:Db2Procedure)
        OPTIONAL MATCH (db2Proc)-[r8]-(sql2:COBOLExecSqlStatement)
        OPTIONAL MATCH (sql2)-[r9]-(db2Table2:Db2Table)
        OPTIONAL MATCH (paragraph)-[r10]-(perform:COBOLPerform)
          
        RETURN
            'COBOLJcl'                                          AS sourceType,
            id(jcl)                                             AS programId,
            jcl.name                                            AS programName,
            apoc.text.regexGroups(jcl.filePath,
                  '.*\\\\[0-9A-Fa-f\\-]{36}\\\\(.+)$')[0][1]    AS programRelativeFilePath,
            id(otherJcl)                                        AS connectedNodeId,
            otherJcl.name                                       AS connectedNodeName,
            apoc.text.regexGroups(otherJcl.filePath,
                  '.*\\\\[0-9A-Fa-f\\-]{36}\\\\(.+)$')[0][1]    AS connectedNodeRelativeFilePath,
            id(r1)                                              AS relProgramConnectedId,
            type(r1)                                            AS relProgramConnectedType,
            id(program)                                         AS jclId,
            program.name                                        AS jclName,
            apoc.text.regexGroups(program.filePath,
                  '.*\\\\[0-9A-Fa-f\\-]{36}\\\\(.+)$')[0][1]    AS jclRelativeFilePath,
            id(r2)                                              AS relJclProgramId,
            type(r2)                                            AS relJclProgramType,
            id(procDiv)                                         AS procDivId,
            'Procedure Division of ' +
            apoc.text.regexGroups(procDiv.filePath,'^.*/(.+)$')[0][1] AS procDivName,
            apoc.text.regexGroups(procDiv.filePath,
                  '.*\\\\[0-9A-Fa-f\\-]{36}\\\\(.+)$')[0][1]    AS procDivRelativeFilePath,
            id(r3)                                              AS relProgramToProcDivId,
            type(r3)                                            AS relProgramToProcDivType,
            id(paragraph)                                       AS paragraphId,
            paragraph.name                                      AS paragraphName,
            apoc.text.regexGroups(paragraph.filePath,
                  '.*\\\\[0-9A-Fa-f\\-]{36}\\\\(.+)$')[0][1]    AS paragraphRelativeFilePath,
            id(r4)                                              AS relProcDivToParagraphId,
            type(r4)                                            AS relProcDivToParagraphType,
            id(sql1)                                            AS sqlStmt1Id,
            sql1.name                                           AS sqlStmt1Name,
            apoc.text.regexGroups(sql1.filePath,
                  '.*\\\\[0-9A-Fa-f\\-]{36}\\\\(.+)$')[0][1]    AS sqlStmt1RelativeFilePath,
            id(r5)                                              AS relParagraphToSql1Id,
            type(r5)                                            AS relParagraphToSql1Type,
            id(db2Table1)                                       AS db2Table1Id,
            db2Table1.name                                      AS db2Table1Name,
            apoc.text.regexGroups(db2Table1.filePath,
                  '.*\\\\[0-9A-Fa-f\\-]{36}\\\\(.+)$')[0][1]    AS db2Table1RelativeFilePath,
            id(r6)                                              AS relSql1ToDb2Table1Id,
            type(r6)                                            AS relSql1ToDb2Table1Type,
            id(db2Proc)                                         AS db2ProcId,
            db2Proc.name                                        AS db2ProcName,
            apoc.text.regexGroups(db2Proc.filePath,
                  '.*\\\\[0-9A-Fa-f\\-]{36}\\\\(.+)$')[0][1]    AS db2ProcRelativeFilePath,
            id(r7)                                              AS relSql1ToDb2ProcId,
            type(r7)                                            AS relSql1ToDb2ProcType,
            id(sql2)                                            AS sqlStmt2Id,
            sql2.name                                           AS sqlStmt2Name,
            apoc.text.regexGroups(sql2.filePath,
                  '.*\\\\[0-9A-Fa-f\\-]{36}\\\\(.+)$')[0][1]    AS sqlStmt2RelativeFilePath,
            id(r8)                                              AS relDb2ProcToSql2Id,
            type(r8)                                            AS relDb2ProcToSql2Type,
            id(db2Table2)                                       AS db2Table2Id,
            db2Table2.name                                      AS db2Table2Name,
            apoc.text.regexGroups(db2Table2.filePath,
                  '.*\\\\[0-9A-Fa-f\\-]{36}\\\\(.+)$')[0][1]    AS db2Table2RelativeFilePath,
            id(r9)                                              AS relSql2ToDb2Table2Id,
            type(r9)                                            AS relSql2ToDb2Table2Type,
            id(perform)                                         AS performId,
            perform.name                                        AS performName,
            apoc.text.regexGroups(perform.filePath,
                  '.*\\\\[0-9A-Fa-f\\-]{36}\\\\(.+)$')[0][1]    AS performRelativeFilePath,
            id(r10)                                             AS relParagraphToPerformId,
            type(r10)                                           AS relParagraphToPerformType
    - cyclomaticComplexityHeatMap: |-
        @@@neo4j
        @@@jolt
        @@@set('reports[4]')
        @@@jsonify
        MATCH (p:COBOLParagraph)
        WITH
            apoc.text.regexGroups(p.filePath, '.*[\\\\/](.*)$')[0][1] AS File,
            p.name                                                    AS Paragraph,
            toLower(
            apoc.text.replace(p.rawCode,'(?m)^.{6}\\*.*(\\n|$)','')
            )                                                          AS lowerCode
        
        // 1) Count loop‐headers and total SEARCH occurrences
        WITH
            File,
            Paragraph,
            lowerCode,
            size(split(lowerCode,' perform until '))     - 1   AS performUntilCount,
            size(split(lowerCode,' perform varying '))   - 1   AS performVaryingCount,
            size(split(lowerCode,' search all '))        - 1   AS searchAllCount,
            size(split(lowerCode,' search '))            - 1   AS totalSearchCount
        
        // 2) Now compute “plain” SEARCH, bare PERFORM calls, and all the other tokens
        WITH
            File,
            Paragraph,
            lowerCode,
            performUntilCount,
            performVaryingCount,
            searchAllCount,
            (totalSearchCount - searchAllCount)                AS searchCount,
            size(split(lowerCode,' perform ')) - 1 
                - (performUntilCount + performVaryingCount)    AS performCallCount,
            size(split(lowerCode,' if '))                - 1   AS ifCount,
            size(split(lowerCode,' evaluate '))          - 1   AS evaluateCount,
            size(split(lowerCode,' when '))              - 1   AS whenCount,
            size(split(lowerCode,' other '))             - 1   AS otherCount,
            size(split(lowerCode,' move '))              - 1   AS moveCount,
            size(split(lowerCode,' compute '))           - 1   AS computeCount,
            size(split(lowerCode,' display '))           - 1   AS displayCount,
            size(split(lowerCode,' continue '))          - 1   AS continueCount,
            size(split(lowerCode,' and '))               - 1   AS andCount,
            size(split(lowerCode,' or '))                - 1   AS orCount
            
        // 3) Classify into decision vs process nodes
        WITH
            File,
            Paragraph,
            ifCount,
            evaluateCount,
            whenCount,
            otherCount,
            performUntilCount,
            performVaryingCount,
            searchCount,
            searchAllCount,
            performCallCount,
            moveCount,
            computeCount,
            displayCount,
            continueCount,
            andCount,
            orCount,
        
        // decision nodes = IF + EVALUATE + each loop & search header
            (ifCount
            + evaluateCount
            + performUntilCount
            + performVaryingCount
            + searchCount
            + searchAllCount)        AS decisionNodes,
        
        // process nodes = actions + bare PERFORM calls
            (moveCount
            + computeCount
            + displayCount
            + continueCount
            + performCallCount)      AS processNodes
        
        // 4) Compute Nodes, Edges, and Cyclomatic Complexity
        WITH
            File,
            Paragraph,
            decisionNodes,
            processNodes,
            ifCount,
            whenCount,
            otherCount,
            performUntilCount,
            performVaryingCount,
            searchCount,
            searchAllCount,
            andCount,
            orCount,
        
        // total nodes = all nodes + start & exit
            (decisionNodes + processNodes + 2)      AS nodes,
        
        // total edges =
        //   2 base (entry & exit)
        // + 2 per IF
        // + 1 per WHEN/OTHER branch
        // + 2 per loop/search header
        // + 1 per boolean operator
        // + (processNodes - 1) sequential links
            (
            2
            + (ifCount * 2)
            + (whenCount + otherCount)
            + ((performUntilCount
                + performVaryingCount
                + searchCount
                + searchAllCount) * 2)
            + andCount
            + orCount
            + (processNodes - 1)
            )                              AS edges
        
        RETURN
            File + ' - ' + Paragraph       AS Unit,
            nodes                          AS Nodes,
            edges                          AS Edges,
            (edges - nodes + 2)            AS CyclomaticComplexity
    - halsteadIndexMaintainability: |-
        @@@neo4j
        @@@jolt
        @@@set('reports[5]')
        @@@jsonify
        MATCH (p:COBOLParagraph)
        WITH
            apoc.text.regexGroups(p.filePath, '.*[\\\\/](.*)')[0][1] AS filePath,
            p.rawCode                                    AS code
          
        // List of COBOL operators/keywords
        WITH filePath, code,
            ['ADD','SUBTRACT','MULTIPLY','DIVIDE','COMPUTE','MOVE','SET','IF','ELSE',
             'PERFORM','UNTIL','VARYING','ACCEPT','DISPLAY','+','-','*','/','=',
             'IS EQUAL TO','<','IS LESS THAN','>','IS GREATER THAN','<=',
             'IS LESS THAN OR EQUAL TO','>=','IS GREATER THAN OR EQUAL TO','<>',
             'IS NOT EQUAL TO','AND','OR','NOT','STRING','UNSTRING','INSPECT'] AS operators
          
        // Tokenize code
        WITH filePath,
            [ w IN split(
            replace(replace(replace(replace(toUpper(code),
            '.', ' . '),
            ',', ' , '),
            '(', ' ( '),
            ')', ' ) ')
            ,' ') | w ] AS tokens,
            operators
          
        // Find used operators & operands
        WITH filePath,
            [t IN tokens WHERE t IN operators]        AS usedOpsList,
            [t IN tokens WHERE t <> '' AND NOT t IN operators] AS operandsList
          
        // Flatten lists
        WITH filePath,
            reduce(a = [], x IN usedOpsList   | a + x) AS allUsedOps,
            reduce(a = [], x IN operandsList  | a + x) AS allOperands
          
        // Total counts
        WITH filePath,
            size(allUsedOps)  AS N1,
            size(allOperands) AS N2,
            allUsedOps,
            allOperands
          
        // Unique counts
        WITH filePath,
            N1,
            N2,
            reduce(a = [], x IN allUsedOps  | CASE WHEN x IN a THEN a ELSE a + x END)   AS uniqueOps,
            reduce(a = [], x IN allOperands | CASE WHEN x IN a THEN a ELSE a + x END)   AS uniqueOperands
          
        // Now compute n1, n2 and derived metrics in two steps
        WITH filePath,
            N1,
            N2,
            size(uniqueOps)      AS n1,
            size(uniqueOperands) AS n2
          
        // Final metrics
        WITH filePath,
            n1,
            n2,
            N1,
            N2,
            (n1 + n2)             AS vocabulary,
            (N1 + N2)             AS totalLength,
            (n1 * log(n1) + n2 * log(n2)) AS calculatedLength,
            ((n1 + n2) * log(n1 + n2))    AS volume,
            ((n1 / 2.0) * (N2 / n2))      AS difficulty,
            ((n1 / 2.0) * (N2 / n2)) * ((n1 + n2) * log(n1 + n2)) AS effort
              
        RETURN
            filePath,
            n1,
            n2,
            N1,
            N2,
            ROUND(vocabulary,       2) AS Vocabulary,
            ROUND(totalLength,      2) AS TotalLength,
            ROUND(calculatedLength, 2) AS CalculatedLength,
            ROUND(volume,           2) AS Volume,
            ROUND(difficulty,       2) AS Difficulty,
            ROUND(effort,           2) AS Effort
    - jclStatistics: |-
        @@@neo4j
        @@@jolt
        @@@set('reports[6]')
        @@@jsonify
        MATCH (j:COBOLJcl)
        WHERE j.rawCode IS NOT NULL
        // Step 1: Standardize all line breaks to '\n'
        WITH j,
             replace(replace(j.rawCode, '\r\n', '\n'), '\r', '\n') AS standardizedJcl
        // Step 2: Split the standardized JCL into individual lines
        WITH j, split(standardizedJcl, '\n') AS lines
        // Step 3: Filter lines that start with '//' after trimming leading whitespace
        WITH j,
             [line IN lines WHERE trim(line) STARTS WITH '//'] AS jclLines
        // Step 4: Calculate counts based on the content of jclLines
        WITH j, jclLines,
        
             // Count lines executing procedures (EXEC PROC=...)
             size([line IN jclLines WHERE toLower(line) CONTAINS 'exec proc=']) AS jobCalls,
        
             // Count lines defining load libraries (STEPLIB DD DSN=...) by removing all spaces
             size([line IN jclLines WHERE replace(toLower(line), ' ', '') STARTS WITH '//steplibdddsn=']) AS loadLibraries,
        
             // Count lines defining data files (DD DSN=...) excluding STEPLIB
             size([line IN jclLines WHERE toLower(line) CONTAINS 'dd dsn=' AND NOT replace(toLower(line), ' ', '') STARTS WITH '//steplibdddsn=']) AS dataFiles,
        
             // Count lines executing COBOL programs (EXEC PGM=...)
             size([line IN jclLines WHERE toLower(line) CONTAINS 'exec pgm=']) AS cobolCalls
        // Step 5: Return the aggregated results
        RETURN 
            j.name AS JobName,
            jobCalls AS JobCalls,
            dataFiles AS DataFiles,
            loadLibraries AS LoadLibraries,
            cobolCalls AS CobolModulesCalled
    - paragraphsUsage: |-
        @@@neo4j
        @@@jolt
        @@@set('reports[7]')
        @@@jsonify
        MATCH (prog:COBOLProgram)-[:CONTAINS]->(pd:COBOLProcedureDivision)-[:CONTAINS]->(p:COBOLParagraph)
        OPTIONAL MATCH (perf:COBOLPerform)
        WHERE perf.name = p.name
        WITH p.name as ParagraphName,
             prog.name as ProgramName,
             COUNT(perf) as TimesReferenced
        RETURN 
            ProgramName,
            ParagraphName,
            TimesReferenced
        ORDER BY 
            ProgramName ASC,
            TimesReferenced DESC, 
            ParagraphName ASC
    - goToAnalysis: |-
        @@@neo4j
        @@@jolt
        @@@set('reports[8]')
        @@@jsonify
        MATCH (p:COBOLParagraph)
        WITH 
            p.name as ParagraphName, 
            p.rawCode as Code,
            size(split(toLower(p.rawCode), 'go to')) - 1 as TotalGoToCount,
        
            // Detect unconditional GO TO statements
            size([x IN split(toLower(p.rawCode), '\n') 
                WHERE x CONTAINS 'go to' 
                AND NOT (x CONTAINS 'if' AND x CONTAINS 'go to')
                AND NOT (x CONTAINS 'else' AND x CONTAINS 'go to')
                AND NOT (x CONTAINS 'when' AND x CONTAINS 'go to')
            ]) as UnconditionalGoToCount,
        
            // Detect conditional GO TO statements
            size([x IN split(toLower(p.rawCode), '\n') 
                WHERE (x CONTAINS 'if' AND x CONTAINS 'go to')
                   OR (x CONTAINS 'else' AND x CONTAINS 'go to')
                   OR (x CONTAINS 'when' AND x CONTAINS 'go to')
            ]) as ConditionalGoToCount
        
        RETURN 
            ParagraphName,
            TotalGoToCount,
            UnconditionalGoToCount,
            ConditionalGoToCount
            //Code as OriginalCode
        ORDER BY 
            ConditionalGoToCount DESC,
            ParagraphName ASC
    - missingInventory: |-
        @@@neo4j
        @@@jolt
        @@@set('reports[9]')
        @@@jsonify
        MATCH (m:MissingObject)
        WITH m.name                           AS name,
            m.type                            AS type,
            m.originName                      AS originName,
            m.originType                      AS originType,
            m.firstLine                       AS firstLine,
            m.lastLine                        AS lastLine
        RETURN name, type, originName, originType, firstLine, lastLine
        ORDER BY name ASC
      # TODO: Check the lines and paragraphs that maybe is connected to a Screen
    - deadCode: |-
        @@@neo4j
        @@@jolt
        @@@set('reports[10]')
        @@@jsonify
        // 1) Build the “liveSet” of reachable paragraphs
        MATCH (entry:COBOLParagraph)
        WHERE entry.procedureDivisionOrder = 0
        WITH collect(entry) AS entries
        CALL {
          WITH entries
          UNWIND entries AS e
          MATCH (e)-[:CONTAINS]->(perf:COBOLPerform)
          MATCH (live:COBOLParagraph)
            WHERE live.name = perf.name
          RETURN collect(DISTINCT live) AS lives
        }
        WITH entries + lives AS liveSet
        
        // 2) Dead paragraphs
        MATCH (dead:COBOLParagraph)
        WHERE dead.procedureDivisionOrder <> 0
          AND NOT dead IN liveSet
        WITH collect({
          elementType:   'Dead Paragraph',
          elementName:   dead.name,
          line:          dead.firstLine,
          file:          dead.filePath,
          numberOfLines: size(split(dead.rawCode, '\n'))
        }) AS deadParas
        
        // 3) Unused WORKING-STORAGE variables
        MATCH (v:COBOLStorage:Variable)
        WHERE NOT EXISTS {
          MATCH (p:COBOLParagraph) WHERE v.name IN p.dataIdentifiers
         }
        WITH deadParas,
             collect({
               elementType:   'Unused Variable',
               elementName:   v.name,
               line:          v.firstLine,
               file:          v.filePath,
               numberOfLines: NULL
             }) AS unusedVars
        
        // 4) Dead SQL against non-existent tables
        MATCH (sql:COBOLExecSqlStatement)
        WHERE sql.rawCode CONTAINS 'MISSING_TABLE'
        WITH deadParas, unusedVars,
             collect({
               elementType:   'Dead SQL',
               elementName:   sql.rawCode,
               line:          NULL,
               file:          sql.filePath,
               numberOfLines: NULL
             }) AS deadSqls
        
        // 5) Dead programs (never called / referenced)
        MATCH (prog:COBOLProgram)
        WHERE NOT EXISTS {
          MATCH (:COBOLCall {name: prog.name})
        }
        AND NOT EXISTS {
          MATCH (:MissingObject {name: prog.name, originType: 'COBOLProgram'})
        }
        WITH deadParas, unusedVars, deadSqls,
             collect({
               elementType:   'Dead Program',
               elementName:   prog.name,
               line:          prog.firstLine,
               file:          prog.filePath,
               numberOfLines: size(split(prog.rawCode, '\n'))
             }) AS deadPrograms
        
        // 6) Combine all into one table
        UNWIND (deadParas + unusedVars + deadSqls + deadPrograms) AS row
        RETURN
          row.elementType                                 AS ElementType,
          apoc.text.regexGroups(row.file,
            '.*\\\\[0-9A-Fa-f\\-]{36}\\\\(.+)$')[0][1]    AS programRelativeFilePath,
          row.elementName                                 AS ElementName,
          row.line                                        AS Line,
          row.numberOfLines                               AS LinesOfCode
        ORDER BY ElementType, programRelativeFilePath, Line
    - deadCodeMetadata: |-
        @@@neo4j
        @@@jolt
        @@@set('reports[11]')
        @@@jsonify
        // 1) Build the liveSet of reachable paragraphs
        MATCH (entry:COBOLParagraph)
        WHERE entry.procedureDivisionOrder = 0
        WITH collect(entry) AS entries
        CALL {
          WITH entries
          UNWIND entries AS e
          MATCH (e)-[:CONTAINS]->(perf:COBOLPerform)
          MATCH (live:COBOLParagraph)
          WHERE live.name = perf.name
          RETURN collect(DISTINCT live) AS lives
        }
        WITH entries + lives AS liveSet
          
        // 2) Identify dead paragraphs and compute their total lines
        MATCH (deadP:COBOLParagraph)
        WHERE deadP.procedureDivisionOrder <> 0
        AND NOT deadP IN liveSet
        WITH COLLECT(deadP)                               AS deadParagraphs,
            SUM(SIZE(SPLIT(deadP.rawCode, '\n')))        AS deadParagraphLines
          
        // 3) Totals for all paragraphs
        MATCH (p:COBOLParagraph)
        WITH deadParagraphs, deadParagraphLines,
        COUNT(p)                                      AS totalParagraphs,
        SUM(SIZE(SPLIT(p.rawCode, '\n')))             AS totalParagraphLines
        
        // 4) Variables: total vs unused
        MATCH (v:COBOLStorage:Variable)
        WITH deadParagraphs, deadParagraphLines,
        totalParagraphs, totalParagraphLines,
        COUNT(v)                                      AS totalVariables,
        SUM(
          CASE
          WHEN NOT EXISTS {
            MATCH (par:COBOLParagraph)
            WHERE v.name IN par.dataIdentifiers
          } THEN 1 ELSE 0 END)                        AS unusedVariables
        
        // 5) SQL statements: total vs dead
        MATCH (sql:COBOLExecSqlStatement)
        WITH
        deadParagraphs,
        deadParagraphLines,
        totalParagraphs,
        totalParagraphLines,
        totalVariables,
        unusedVariables,
        COUNT(sql)                                    AS totalSqlStatements,
        SUM(
          CASE 
            WHEN sql.rawCode CONTAINS 'MISSING_TABLE' 
          THEN 1 ELSE 0 END
        )                                             AS deadSqlStatements
        
        // 6) Programs: total vs dead
        MATCH (prog:COBOLProgram)
        WITH deadParagraphs, deadParagraphLines, 
          totalParagraphs, totalParagraphLines, 
          totalVariables, unusedVariables,
          totalSqlStatements, deadSqlStatements,
        COUNT(prog)                                   AS totalPrograms,
        SUM(
        CASE
          WHEN NOT EXISTS { MATCH (:COBOLCall   {name: prog.name}) }
          AND NOT EXISTS { 
            MATCH (:MissingObject {name: prog.name,originType:'COBOLProgram'}) 
          }
          THEN 1 ELSE 0
        END
        )                                             AS deadPrograms
          
        // 7) Return the metadata
        RETURN
          // Paragraphs
          totalParagraphs                              AS totalParagraphs,
          totalParagraphLines                          AS totalParagraphLines,
          size(deadParagraphs)                         AS deadParagraphCount,
          deadParagraphLines                           AS deadParagraphLines,
          ROUND(100.0 * size(deadParagraphs) / totalParagraphs, 1)   AS pctDeadParagraphs,
          ROUND(100.0 * deadParagraphLines / totalParagraphLines, 1) AS pctDeadParagraphLines,
          
          // Variables
          totalVariables                               AS totalVariables,
          unusedVariables                             AS deadVariableCount,
          ROUND(100.0 * unusedVariables / totalVariables, 1)       AS pctDeadVariables,
          
          // SQL
          totalSqlStatements                          AS totalSqlStatements,
          deadSqlStatements                           AS deadSqlCount,
          ROUND(100.0 * deadSqlStatements / totalSqlStatements, 1) AS pctDeadSqls,
          
          // Programs
          totalPrograms                               AS totalPrograms,
          deadPrograms                                AS deadProgramCount,
          ROUND(100.0 * deadPrograms / totalPrograms, 1)         AS pctDeadPrograms;
    - mipsComplexityHeatMap: |-
        @@@neo4j
        @@@jolt
        @@@set('reports[12]')
        @@@jsonify
        MATCH (prog:COBOLProgram)-[:CONTAINS]-(procDiv:COBOLProcedureDivision)-[:CONTAINS]->(para:COBOLParagraph)
        WITH prog.name       AS Program,
        para.name       AS Paragraph,
        toLower(para.rawCode) AS code,
        para.filePath   AS fp
        
        // IO [HIGH]
        CALL {
          WITH code, Paragraph
          WITH toFloat(
          size(split(code,'write')) +
          size(split(code,'open')) +
          size(split(code,'close')) +
          size(split(code,'read'))-4) AS rawValue, Paragraph
          RETURN CASE
            WHEN rawValue = 0   THEN 0
            WHEN rawValue < 5   THEN ROUND(rawValue / 5.0 * 3 * 0.3, 2)
            WHEN rawValue <= 15 THEN ROUND(3 * 0.3 + ((rawValue - 5) / 5) * (3 * 0.5 - 3 * 0.3), 2)
            ELSE ROUND (3 * 0.5 + ((rawValue - 15) / 15) * (3 * 0.7 - 3 * 0.5), 2)
            END AS `IO [HIGH]`
        }
          
        // SQL Complexity [HIGH]
        CALL {
          WITH Paragraph
          OPTIONAL MATCH (para)-[:CONTAINS]->(sql:COBOLExecSqlStatement)
          WHERE sql.sqlClause IS NOT NULL AND toLower(sql.sqlClause) CONTAINS 'select'
          WITH
          ( CASE WHEN toLower(sql.sqlClause) CONTAINS 'select *' THEN 2 ELSE 0 END
          + CASE WHEN toLower(sql.sqlClause) =~ '(?i).*(sum|avg|max|min|count)\\s*\\(.*\\).*' THEN 2 ELSE 0 END
          + (size(split(toLower(sql.sqlClause),'select')) - 1)
          + CASE WHEN size(split(toLower(sql.sqlClause),' and ')) - 1
          + size(split(toLower(sql.sqlClause),' or '))-1 > 3 THEN 2
          WHEN size(split(toLower(sql.sqlClause),' and ')) - 1
          + size(split(toLower(sql.sqlClause),' or ')) - 1 > 0 THEN 1
          ELSE 0 END
          + CASE WHEN sql.sqlClause CONTAINS ':' THEN 2 ELSE 0 END
          ) AS rawValue
          RETURN CASE
            WHEN rawValue = 0  THEN 0
            WHEN rawValue < 4  THEN ROUND(rawValue / 4.0 * 3 * 0.3, 2)
            WHEN rawValue <= 7 THEN ROUND(3 * 0.3 + ((rawValue - 4) / 4) * (3 * 0.5 - 3 * 0.3), 2)
            ELSE ROUND(3 * 0.5 + ((rawValue - 7) / 7) * (3 * 0.7 - 3 * 0.5), 2)
            END AS `SQL Complexity [HIGH]`
        }
          
        // Large Field Access [HIGH]
        CALL {
          WITH fp
          OPTIONAL MATCH (n:COBOLStorage {filePath:fp, level:1})
          WITH COLLECT(n) AS recs
          WITH reduce(s=0, r IN recs | s
          + size([(r)-[:CONTAINS*]->(f:COBOLStorage) WHERE f.level IN [5,10] | f])) AS rawValue
          RETURN CASE
            WHEN rawValue = 0   THEN 0
            WHEN rawValue < 10  THEN ROUND(rawValue / 5.0 * 3 * 0.3, 2)
            WHEN rawValue <= 19 THEN ROUND(3 * 0.3 + ((rawValue - 10) / 10) * (3 * 0.5 - 3 * 0.3), 2)
            ELSE ROUND(3 * 0.5 + ((rawValue - 19) / 19) * (3 * 0.7 - 3 * 0.5), 2)
            END AS `Large Field Access [HIGH]`
        }
          
        // File Section [HIGH]
        CALL {
          WITH fp
          OPTIONAL MATCH (fs:COBOLFileSection {filePath:fp})
          WITH (
          (CASE WHEN toLower(fs.rawCode) CONTAINS ' recording mode is f ' THEN 1 ELSE 2 END)
          + (CASE WHEN toLower(fs.rawCode) CONTAINS ' indexed '            THEN 2 ELSE 1 END)
          + (
          CASE WHEN fs.rawCode CONTAINS ' BLOCK CONTAINS 0 RECORDS '    THEN 2.5
          WHEN fs.rawCode =~ '(?i)BLOCK CONTAINS \\d+ RECORDS'           THEN 1.5 ELSE 2 END
          )
          + (
          CASE WHEN size(split(fs.rawCode,'FD ')) > 3 THEN 2
          WHEN size(split(fs.rawCode,'FD '))>1 THEN 1.5
          ELSE 1 END
          )
          )/2.67 AS rawValue
          RETURN ROUND(rawValue, 2) AS `File Section [HIGH]`
        }
          
        // Disk or Tape [HIGH]
        CALL {
          WITH fp
          OPTIONAL MATCH (env:COBOLEnvironmentDivision {filePath:fp})
          WITH size([x IN split(toLower(env.rawCode),' ') WHERE x='disk']) * 2
          + size([x IN split(toLower(env.rawCode),' ') WHERE x='tape']) AS rawValue
          RETURN ROUND(rawValue, 2) AS `Disk or Tape [HIGH]`
        }
          
        // Nested and Complex Loops [MEDIUM]
        CALL {
          WITH code
          WITH toFloat(
          (size(split(code,'perform')) - 1)
          + (size(split(code,'until')) - 1)
          + (size(split(code,'varying')) - 1)
          + (CASE WHEN code =~ '(?s).*perform.*perform.*' THEN 2 ELSE 0 END)
          + (CASE WHEN code =~ '(?s).*(if.*and.*or|or.*and).*' THEN 1 ELSE 0 END)
          + (CASE WHEN code =~ '(?s).*(table|array|occurs).*' THEN 1 ELSE 0 END)
          ) AS rawValue
          RETURN CASE
            WHEN rawValue = 0   THEN 0
            WHEN rawValue < 3   THEN ROUND(rawValue / 3.0 * 2 * 0.3, 2)
            WHEN rawValue < 5 THEN ROUND(2 * 0.3 + ((rawValue - 3) / 3) * (2 * (0.5 - 0.3)), 2)
            ELSE ROUND (2 * 0.5 + ((rawValue - 5) / 5) * (2 * (0.7 - 0.5)), 2)
            END AS `Nested and Complex Loops [MEDIUM]`
        }
          
        // Inefficient Search and Sort [MEDIUM]
        CALL {
          WITH code
          WITH toFloat(
          (CASE WHEN code CONTAINS "sort " AND NOT code CONTAINS "using" THEN 3
          WHEN code CONTAINS "sort " THEN 2 ELSE 0 END)
          + (CASE WHEN code CONTAINS "search " AND NOT code CONTAINS "search all" THEN 3
          WHEN code CONTAINS "search all" THEN 1
          WHEN code CONTAINS "perform varying" OR code CONTAINS "perform until" THEN 2
          WHEN code CONTAINS "redefines" AND (code CONTAINS "occurs" OR code CONTAINS "indexed by") THEN 2
          ELSE 0 END)
          )/2.0 AS rawValue
          RETURN ROUND(rawValue) AS `Inefficient Search and Sort [MEDIUM]`
        }
          
        // Large Working Storage Section [MEDIUM]
        CALL {
          WITH fp
          OPTIONAL MATCH (s:COBOLStorage {filePath:fp})
          WITH count(s) AS rawValue
          RETURN CASE
          WHEN rawValue = 0   THEN 0
          WHEN rawValue < 10   THEN ROUND(rawValue / 10.0 * 2 * 0.3, 2)
          WHEN rawValue < 20 THEN ROUND(2 * 0.3 + ((rawValue - 10) / 10) * (2 * (0.5 - 0.3)), 2)
          ELSE ROUND (2 * 0.5 + ((rawValue - 20) / 20) * (2 * (0.7 - 0.5)), 2)
          END AS `Large Working Storage Section [MEDIUM]`
        }
          
        // Unindexed Search [LOW]
        CALL {
          WITH code
          WITH toFloat(
          (CASE WHEN code CONTAINS 'read ' AND NOT code CONTAINS 'key is' THEN 3
          WHEN code CONTAINS 'read ' THEN 1 ELSE 0 END)
          + (CASE WHEN code CONTAINS 'perform ' AND code CONTAINS 'until ' AND (code CONTAINS '>' OR code CONTAINS '<' OR code CONTAINS '=') THEN 3 ELSE 0 END)
          )/2.0 AS rawValue
          RETURN ROUND(rawValue) AS `Unindexed Search [LOW]`
        }
          
        // Extensive Error Checking [LOW]
        CALL {
          WITH code
          WITH toFloat(
          (CASE WHEN code CONTAINS "display" THEN 1 ELSE 0 END)
          + (CASE WHEN code CONTAINS "perform" AND code CONTAINS "if" THEN 1 ELSE 0 END)
          + (CASE WHEN code CONTAINS "evaluate" OR code CONTAINS "if" THEN 1 ELSE 0 END)
          + (CASE WHEN code CONTAINS "debug" OR code CONTAINS "debug-mode" THEN 1 ELSE 0 END)
          + (CASE WHEN code CONTAINS "call 'cee3dmp'" THEN 1 ELSE 0 END)
          + (CASE WHEN code CONTAINS "not numeric" OR code CONTAINS "validate" THEN 1 ELSE 0 END)
          + (CASE WHEN code CONTAINS "perform" AND code CONTAINS "if ws-error-code" THEN 1 ELSE 0 END)
          + (CASE WHEN code CONTAINS "call 'abend'" THEN 1 ELSE 0 END)
          ) * 3.0 / 8.0 AS rawValue
          RETURN ROUND(rawValue, 2) AS `Extensive Error Checking [LOW]`
        }
          
        RETURN
          Program,
          Paragraph,
          `IO [HIGH]`,
          `SQL Complexity [HIGH]`,
          `Large Field Access [HIGH]`,
          `File Section [HIGH]`,
          `Disk or Tape [HIGH]`,
          `Nested and Complex Loops [MEDIUM]`,
          `Inefficient Search and Sort [MEDIUM]`,
          `Large Working Storage Section [MEDIUM]`,
          `Unindexed Search [LOW]`,
          `Extensive Error Checking [LOW]`,
          ROUND(coalesce(`IO [HIGH]`,0)
          +coalesce(`SQL Complexity [HIGH]`,0)
          +coalesce(`Large Field Access [HIGH]`,0)
          +coalesce(`File Section [HIGH]`,0)
          +coalesce(`Disk or Tape [HIGH]`,0)
          +coalesce(`Nested and Complex Loops [MEDIUM]`,0)
          +coalesce(`Inefficient Search and Sort [MEDIUM]`,0)
          +coalesce(`Large Working Storage Section [MEDIUM]`,0)
          +coalesce(`Unindexed Search [LOW]`,0)
          +coalesce(`Extensive Error Checking [LOW]`,0), 2)
          AS Total
          ORDER BY Total DESC, Program, Paragraph
    - callGraphFlowDiagram: |-
        @@@freemarker
        @@@retry(3, "${#recipe['templates']['retryDiagram'].replace('!!diagram!!', #project['currentDiagram'])}")
        @@@agent("BEDROCK")
        @@@extractMarkdownCode
        @@@set('project.currentDiagram')
        @@@plantuml
        @@@_spel("${#project['reports'][13].put('content', {'data': #content})}")
        
        Based on the plantuml script which represent a callgraph diagram, 
        only ADD in this script the DESCRIPTION of each program, paragraph, and file.
        
        Return only the PlantUML code, without any additional text or comments.
        
        [PLANTUML]
        @startuml
        ' ==========================================================
        '        COBOL Application Callgraph Component Diagram
        ' ==========================================================
        left to right direction
        scale 4000 width
        
        title COBOL Application Callgraph Component Diagram
        
        header
            This diagram presents the high-level architecture and callgraph for the COBOL application,
            including programs, procedures (paragraphs), and external files.
        endheader
        
        ' ---- Style & Professional Visual Settings ----
        skinparam componentStyle rectangle
        skinparam shadowing true
        skinparam backgroundColor #F5F7FA
          
        skinparam package {
          BorderColor #1976D2
          BackgroundColor #E3F2FD
        }
        skinparam component {
          BorderColor #388E3C
          BackgroundColor #C8E6C9
        }
        skinparam interface {
          BorderColor #AB47BC
          BackgroundColor #F3E5F5
        }
        skinparam rectangle {
          BorderColor #00838F
          BackgroundColor #B2EBF2
        }
        skinparam Arrow {
          Color #D84315
          Thickness 2
        }
        skinparam note {
          BackgroundColor #FFFDE7
          BorderColor #FBC02D
        }
        
        legend left
          <b>Legend</b>
          - <&rectangle> Program (Main COBOL Executable)
          - <&component> Paragraph (Procedure)
          - <&interface> File (Input/Output)
          - <color:#D84315>--></color> PERFORM/Call within Program
          - <color:#1976D2>..></color> CALL to another program or file access
        endlegend
          
        ' ----------------------------------------------------------
        '           Main COBOL Programs (Application Entry Points)
        ' ----------------------------------------------------------
        
        package "COBOL Application" {
          <#list flows![] as program>
            rectangle "${program.name}\n(${program.mainOrSecondary} COBOL Program)" as ${program.label} ${program.color}
          </#list>
        }
        
        ' ----------------------------------------------------------
        '           External Files (Deduplicated)
        ' ----------------------------------------------------------
        <#assign seenFiles = []>
        <#list ios![] as io>
        <#if !(seenFiles?seq_contains(io.dataObjectLabel))>
        interface "${io.dataObjectName}\n(${io.dataObjectType})" as ${io.dataObjectLabel}
        <#assign seenFiles = seenFiles + [io.dataObjectLabel]>
        </#if>
        </#list>
          
        ' ----------------------------------------------------------
        '           Key Paragraphs (Procedures) in Each Program (Deduplicated, Prefixed)
        ' ----------------------------------------------------------
        <#assign seenParagraphs = []>
        <#list flows![] as program>
        ' ----------------------------------------------------------
        '           Key Paragraphs (Procedures) in ${program.name}
        ' ----------------------------------------------------------
          
        package "${program.label} Procedures" {
          <#list program.paragraphs![] as paragraph>
          <#-- Create a unique label per program+paragraph -->
          <#assign uniqueParaLabel = program.label + "_" + paragraph.label>
          <#if !(seenParagraphs?seq_contains(uniqueParaLabel))>
          component "${paragraph.name}" as ${uniqueParaLabel}
          note right of ${uniqueParaLabel}
          ${paragraph.description!"Description here!"}
          end note
          <#assign seenParagraphs = seenParagraphs + [uniqueParaLabel]>
          </#if>
          </#list>
        }
          </#list>
          
        ' ----------------------------------------------------------
        '           Program Calls & Perform Relationships (Deduplicated)
        ' ----------------------------------------------------------
        <#assign seenPerformArrows = []>
        <#list flows![] as program>
          <#list program.paragraphs![] as paragraph>
            <#assign src = program.label + "_" + paragraph.label>
            <#if paragraph.isEntryPoint == true>
              <#assign arrow = program.label + "-->" + src + ":Entry">
              <#if !(seenPerformArrows?seq_contains(arrow))>
                ${program.label} --> ${src} : "Entry"
                <#assign seenPerformArrows = seenPerformArrows + [arrow]>
              </#if>
            </#if>
            <#list paragraph.performs![] as perform>
              <#assign tgt = program.label + "_" + perform.label>
              <#assign arrow = src + "-->" + tgt + ":PERFORM">
              <#if !(seenPerformArrows?seq_contains(arrow))>
                ${src} --> ${tgt} : "PERFORM"
                <#assign seenPerformArrows = seenPerformArrows + [arrow]>
              </#if>
            </#list>
          </#list>
        </#list>
        
        ' ----------------------------------------------------------
        '           File Interactions (Reads/Writes, Deduplicated)
        ' ----------------------------------------------------------
        <#assign seenFileArrows = []>
        <#list ios![] as io>
        <#-- Prefix paragraph with program.label for uniqueness -->
        <#assign src = io.programLabel + "_" + io.paragraphLabel>
        <#assign arrow = src + "..>" + io.dataObjectLabel + ":" + io.rw>
        <#if !(seenFileArrows?seq_contains(arrow))>
        ${src} ..> ${io.dataObjectLabel} : "${io.rw}"
        <#assign seenFileArrows = seenFileArrows + [arrow]>
        </#if>
        </#list>
          
        ' ----------------------------------------------------------
        '           Footer
        ' ----------------------------------------------------------
        footer
            Generated by Capco
            For developers, architects, business, and tech stakeholders
        endfooter
        @enduml
        [/PLANTUML]
    - blueprintFlow: |-
        @@@freemarker
        @@@_spel("${#project['reports'][14].put('content', {'data': #content})}")
        @startuml
        ' ========================================================
        '           COBOL Application Microservice Blueprint
        ' ========================================================
        left to right direction
        scale 4000 width
        
        title COBOL Microservice Application Blueprint
        header
            Blueprint of COBOL microservices and function dependencies.
            Solid arrow: direct call (same microservice).
            Dashed arrow: API call (cross-microservice).
        endheader
        
        ' ---- Style Settings ----
        skinparam backgroundColor #F5F7FA
        skinparam componentStyle rectangle
        skinparam shadowing true
        skinparam package {
          BorderColor #1976D2
          BackgroundColor #E3F2FD
        }
        skinparam component {
          BorderColor #388E3C
          BackgroundColor #C8E6C9
        }
        skinparam Arrow {
          Color #D84315
          Thickness 2
        }
        skinparam Legend {
          BackgroundColor #FFFDE7
          BorderColor #FBC02D
        }
          
        <#assign splitByProgram =  $api.configs.options.splitByProgram />
        legend left
          <b>Legend</b>
          <#if splitByProgram>
          <&rectangle> Program (component)
          <#else>
          <&rectangle> Function (component)
          </#if>
          <color:#D84315>--></color> Direct call (same microservice)
          <color:#1976D2>..></color> API call (cross microservice)
        endlegend
          
        footer
          Generated by Capco
          COBOL Forward Engineering Suite | For technical and business stakeholders
        endfooter
          
        ' =========================
        '   MICROSERVICES & FUNCTIONS
        ' =========================
        <#assign paragraphClusterMap = {} />
        <#assign programClusterMap = {} />
        
        <#-- Build a lookup from function to microservice for dependency logic -->
        <#assign microservices = $api.files.clusters>
        <#list microservices as microservice>
          <#list microservice.paragraph as paragraph>
            <#assign paragraphClusterMap = paragraphClusterMap + { (paragraph.name) : microservice.cluster_name } />
            <#assign programName = paragraph.name?split(".")[0] />
            <#assign programClusterMap = programClusterMap + { (programName) : microservice.cluster_name } />
          </#list>
        </#list>
        
        <#-- Packages and exposed components -->
        <#list microservices as microservice>
        package "${microservice.cluster_name}" {
            <#if splitByProgram>
                <#if microservice.paragraph?size gt 0>
                    <#assign programName = microservice.paragraph[0].name?split(".")[0] />
                    <#assign alias = programName?replace(".", "_") />
                component "[${programName}]" as ${alias}
                </#if>
                <#else>
                    <#list microservice.paragraph as paragraph>
                        <#assign alias = paragraph.name?replace(".", "_")?replace("-", "_") />
                component "[${paragraph.name}]" as ${alias}
                    </#list>
                </#if>
        }
        </#list>
        
        ' =========================
        '   FUNCTION DEPENDENCIES
        ' =========================
        
        <#-- Draw arrows: solid for internal, dashed for cross-microservice -->
        <#assign seenLinks = {} />
        <#list microservices as microservice>
          <#list microservice.paragraph as paragraph>
            <#if paragraph.children?? && (paragraph.children?size > 0)>
              <#list paragraph.children as child>
                <#if splitByProgram>
                  <#assign fromProgram = paragraph.name?split(".")[0] />
                  <#assign toProgram = child?split(".")[0] />
                  <#assign fromAlias = fromProgram?replace(".", "_") />
                  <#assign toAlias = toProgram?replace(".", "_") />
                  <#assign fromCluster = programClusterMap[fromProgram]!"" />
                  <#assign toCluster = programClusterMap[toProgram]!"" />
                <#else>
                  <#assign fromAlias = paragraph.name?replace(".", "_")?replace("-", "_") />
                  <#assign toAlias = child?replace(".", "_")?replace("-", "_") />
                  <#assign fromCluster = paragraphClusterMap[paragraph.name]!"" />
                  <#assign toCluster = paragraphClusterMap[child]!"" />
                </#if>
        
                <#assign linkKey = fromAlias + "->" + toAlias />
                <#if !(seenLinks[linkKey]??) && (fromAlias != toAlias)>
                  <#assign seenLinks = seenLinks + { (linkKey): true } />
                  <#if fromCluster == toCluster>
        ${fromAlias} --> ${toAlias} : direct
                  <#else>
        ${fromAlias} ..> ${toAlias} : API
                  </#if>
                </#if>
              </#list>
            </#if>
          </#list>
        </#list>
        @enduml

    - screensReport: |-
        @@@freemarker
        @@@_spel("${#project['reports'][15].put('content', {'data': #content})}")

        <!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
            <script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
            <title>COBOL Screen Report</title>
            <style>
              :root {
                --white: #ffffff;
                --light-gray: #f0f0f0;
                --light-blue: #405cb8;
                --active-text: #ffffff;
              }
              * {
                box-sizing: border-box;
                margin: 0;
                padding: 0;
              }
              body {
                display: flex;
                height: 100vh;
                font-family: sans-serif;
                background: var(--white);
              }
              nav {
                width: 220px;
                background: var(--light-gray);
                overflow-y: auto;
                border-right: 1px solid #ccc;
              }
              nav h2 {
                padding: 16px;
                font-size: 1.2em;
                background: var(--light-blue);
                color: #000;
              }
              nav ul {
                list-style: none;
              }
              nav li {
                border-bottom: 1px solid #ddd;
              }
              nav a {
                display: block;
                padding: 12px 16px;
                text-decoration: none;
                color: #000;
                transition: color 0.3s ease;
              }
              nav a:hover {
                background: var(--light-blue);
                color: var(--active-text);
              }
              nav a.active {
                background: var(--light-blue);
                color: var(--active-text);
              }
              main {
                flex: 1;
                overflow-y: auto;
                padding: 24px;
                background: var(--white);
              }
              section {
                margin-bottom: 48px;
              }
              section h1 {
                font-size: 1.6em;
                color: #333;
                margin-bottom: 8px;
                border-bottom: 2px solid #405cb8;
                padding-bottom: 4px;
              }
              section h2 {
                margin-top: 16px;
                font-size: 1.2em;
                color: #333;
              }
              pre.ascii {
                background: var(--light-gray);
                padding: 16px;
                border-radius: 4px;
                overflow-x: auto;
                font-family: monospace;
                margin-top: 8px;
              }
              .callgraph {
                margin-top: 16px;
              }
              .callgraph img {
                max-width: 100%;
                display: block;
                margin-top: 8px;
                border: 1px solid #ccc;
                border-radius: 4px;
              }
              .callgraph p {
                margin-top: 8px;
                font-style: italic;
                color: #555;
              }
            </style>
          </head>
          <body>
        
            <nav>
              <h2>Cobol Screens</h2>
              <ul>
            <#assign seenScreens = []>
            <#list screens![] as screen>
              <#if !(seenScreens?seq_contains(screen.screenName))>
                <li><a href="#${screen.screenName}" class="active">${screen.screenName}</a></li>
                <#assign seenScreens = seenScreens + [screen.screenName]>
              </#if>
            </#list>
              </ul>
            </nav>
        
            <main>
            <#assign seenScreens = []>
            <#list screens![] as screen>
              <#assign currentScreen = screen.screenName>
              <#if !(seenScreens?seq_contains(currentScreen))>
              <#assign seenScreens = seenScreens + [currentScreen]>
              <section id="${currentScreen}">
                  <#assign seenScreens = []>
                  <#list screens![] as screen>
                  <#assign currentScreen = screen.screenName>
                  <#if !(seenScreens?seq_contains(currentScreen))>
                  <#assign seenScreens += [currentScreen]>
                  <section id="${currentScreen}">
                  <h1>${currentScreen}</h1>
                  
                  <h2>Description</h2>
                  <p>Description of the ${currentScreen}.</p>
                  
                  <h2>ASCII Art</h2>
                  <pre class="ascii">
                  ${screensRef.asciiView[currentScreen]!''}
                  </pre>
                  
                  <div class="callgraph">
                    <h2>Call Graph</h2>
                      <div class="markdown-content">
                <#compress>
                ${screensRef.businessLogic[currentScreen]!''?html}
                </#compress>
                      </div>
                  </section>
                  </#if>
                  </#list>
              </section>
            </#if>
            </#list>
            </main>
        
            <script>
              const sections = document.querySelectorAll('section');
              const navLinks = document.querySelectorAll('nav a');
              window.addEventListener('scroll', () => {
                let current = '';
                sections.forEach(sec => {
                  const top = sec.offsetTop - 100;
                  if (pageYOffset >= top) {
                    current = sec.getAttribute('id');
                  }
                });
                navLinks.forEach(link => {
                  link.classList.toggle('active', link.getAttribute('href') === '#' + current);
                });
              });
            </script>
            <script>
              document.addEventListener('DOMContentLoaded', () => {
              const md = window.markdownit();
              document.querySelectorAll('.markdown-content').forEach(el => {
                // grab the raw markdown (not innerHTML!), convert and replace
                const raw = el.textContent;
                el.innerHTML = md.render(raw);
              });
            });
            </script>
        
          </body>
          </html>
    - plantUMLMock: |-
        @@@agent("AZURE")
        @@@extractMarkdownCode
        @@@_spel("${#project['reports'][16].put('content', {'data': #content})}")
        Create a plantuml script to explain the normal human lifecycle
    # TODO: Check the lines and paragraphs that maybe is connected to a Screen
    # TODO: Find a way to render this in FrontEnd, specially because we don't have something like "metadata" summary on frontEnd right now
    #- deadCode: |-
    #    @@@neo4j
    #    @@@jolt
    #    MATCH (n:COBOLParagraph)
    #      WHERE (
    #      NOT EXISTS {
    #      MATCH (p:COBOLPerform)
    #      WHERE p.name = n.name
    #    }
    #      AND NOT EXISTS {
    #      MATCH (n)
    #      WHERE n.procedureDivisionOrder = 0
    #    }
    #      OR NOT (n)--()
    #      )
    #      WITH n, size(split(n.rawCode, '\\\\n')) AS lines
    #    WITH COLLECT({ paragraph: n.name, rawCode: n.rawCode, lines: lines }) AS deadParagraphs,
    #                                sum(lines) AS deadLines
    #      MATCH (p:COBOLParagraph)
    #      WITH deadParagraphs, deadLines,
    #      count(p) AS totalParagraphs,
    #      sum(size(split(p.rawCode, '\\\\n'))) AS totalLines
    #      RETURN {
    #    metadata: {
    #      totalParagraphs: totalParagraphs,
    #      deadParagraphs: size(deadParagraphs),
    #      totalLines: totalLines,
    #      deadLines: deadLines,
    #      deadLinesPercentage: ROUND(toFloat(deadLines) / totalLines * 10000) / 100.0
    #    },
    #      deadCode: deadParagraphs
    #    } AS deadCodeReport
    #
    - componentDiagram: |-
        @@@default("Failed to generate the diagram")
        @@@_exec("${#recipe['templates']['componentDiagramCypherQuery']}")
        @@@freemarker
        @@@retry(3, "${#recipe['templates']['retryDiagram'].replace('!!diagram!!', #project['currentDiagram'])}")
        @@@agent("AZURE")
        @@@extractMarkdownCode
        @@@set('currentDiagram')
        @@@plantuml
        @@@_spel("${#project['reports'][17].put('content', {'data': #content})}")
        Using the results from the previous Cypher query, create a PlantUML script to generate a component diagram for a COBOL application.

        [PROGRAMS]
        <#list project.currentCardCypherResults![] as resultRow>
        ### COBOL PROGRAM: ${resultRow.program.name}  
        ${resultRow.program.rawCode}
        
        
        </#list>
        

        The component diagram should:
        1. Visualize the high-level components of the system and their relationships
        2. Include COBOL Programs, JCL Jobs, and External Files
        3. Show the relationships between components (calls, executes, reads, writes)
        4. Use appropriate styling to distinguish between different types of components
        5. Include a title, header, and legend
        6. Add detailed descriptive notes for key components explaining their purpose and functionality
        7. Guarantee that NOT create a salt diagram.The response SHOULD NOT HAS @startsalt and @@endsalt tags.

        The diagram should be visually appealing and easy to understand for all stakeholders, including developers, executives, tech leads, and business stakeholders. Use color coding, clear labels, and professional styling to enhance readability and create a business-elegant presentation.

        Specific requirements:
        - Use a professional color scheme with complementary colors
        - Add detailed notes explaining the purpose of each component
        - Include a footer with relevant information
        - Use shadowing and appropriate styling for a modern look
        - Ensure all relationships have descriptive labels
        - Organize the layout for maximum clarity

        Provide the complete PlantUML script that can be directly used to generate the component diagram. The script should be well-commented and structured for easy maintenance.

        Your response should be a valid PlantUML script enclosed between @startuml and @enduml tags.
        
        Ensure that you created a valid PlantUML script without syntax errors!
    - jclProcessingFlow: |-
        @@@default("Failed to generate the diagram")
        @@@_exec("${#recipe['templates']['jclProcessingFlowCypherQuery']}")
        @@@freemarker
        @@@retry(3, "${#recipe['templates']['retryDiagram'].replace('!!diagram!!', #project['currentDiagram'])}")
        @@@agent("AZURE")
        @@@extractMarkdownCode
        @@@set('currentDiagram')
        @@@plantuml
        @@@_spel("${#project['reports'][18].put('content', {'data': #content})}")
        Create a PlantUML script to generate a JCL diagram for a COBOL application. Think of the JCL as a high-level overview of the COBOL application processing flow.

        [JCL]
        <#list currentCardCypherResults![] as resultRow>
        ### JCL: ${resultRow.jcl.name}  
        ${resultRow.jcl.rawCode}
        
        </#list>
        [/JCL]     
        
        The JCL diagram should:
        1. Visualize the high-level components of the JCL jobs or procs and their relationships
        2. Include JCL Jobs or Procs, COBOL Programs (as a black box), and External Files.
        3. Show the relationships between components (calls, executes, reads, writes)
        4. Use appropriate styling to distinguish between different types of components
        5. Include a title, header, and legend
        6. Add detailed descriptive notes for key components explaining their purpose and functionality
        7. Guarantee that NOT create a salt diagram.The response SHOULD NOT HAS @startsalt and @@ENDsalt tags.

        The diagram should be visually appealing and easy to understand for all stakeholders, including developers, executives, tech leads, and business stakeholders. Use color coding, clear labels, and professional styling to enhance readability and create a business-elegant presentation.

        Specific requirements:
        - Use a professional color scheme with complementary colors
        - Add detailed notes explaining the purpose of each component
        - Include a footer with relevant information
        - Use shadowing and appropriate styling for a modern look
        - Ensure all relationships have descriptive labels
        - Organize the layout for maximum clarity

        Provide the complete PlantUML script that can be directly used to generate the JCL diagram. The script should be well-commented and structured for easy maintenance.

        Your response should be a valid PlantUML script enclosed between @startuml and @enduml tags.
        
        Ensure that you created a valid PlantUML script without syntax errors!
  joltNeo4jTableToJson: |-
    [
      {
        "operation": "shift",
        "spec": {
          "results": {
            "*": {
              "data": {
                "*": {
                  "row": {
                    "*": "[&2].@(4,columns[&0])"
                  }
                }
              }
            }
          }
        }
      }
    ]
  joltNeo4jSingleObjectsToJson: |-
    [
      {
        "operation": "shift",
        "spec": {
          "results": {
            "*": {
              "data": {
                "*": {
                  "row": {
                    "*": "[&2]"
                  }
                }
              }
            }
          }
        }
      }
    ]

  joltNeo4jTableToHeadersAndRows: |-
    [
      {
        "operation": "shift",
        "spec": {
          "results": {
            "*": {
              "columns": "headers",
              "data": {
                "*": {
                  "row": "rows[]"
                }
              }
            }
          }
        }
      }
    ]

  screenAsciiView: |-
    @@@freemarker
    @@@agent("AZURE")
    @@@extractMarkdownCode
    @@@mapPut(screensRef.asciiView, ${#fileName})
    
    Purpose: Build a visual representation of the screen in ASCII of the COBOL code provided.

    2. Build a visual representation of the screen in ASCII
    3. Return only the ASCII representation as response. Do not include any comments or analysis in this file
        
    [SCREEN COBOL CODE]
    ${screens?filter(it -> it.screenName == fileName)?first.screenCode!''}
    [/SCREEN COBOL CODE]

  screenBusinessLogic: |-
    @@@freemarker 
    @@@agent("AZURE")
    @@@mapPut(screensRef.businessLogic, ${#fileName})

    [SCREEN]
    ${screens?filter(it -> it.screenName == fileName)?first.screenCode!''}
    [/SCREEN]
    
    ${screensRef.asciiView[fileName]!'‹no ascii view›'}

    COBOL Analyzer Prompt
    Purpose: Extract fields, types, and metadata from COBOL copybooks for downstream processing.

    1. ScreenCode
     - screenTitle = Extract the screen title from the COBOL code
     - screenCode = Extract screen code from CSECT
    
    2. ScreenPath: 
     - extract from the logic the path for the screen 
    
    3. Analyse the type of page at hand
      - pageType = 'selectMenu' when it is a kind of menu page, where the user can make one selection (like open, view, update) and one single input, this is a SelectionMenu pageType
      - pageType = 'form' when it is not a simple selection and there are multiple fields for user input.
    
    3. Analyse the COBOL copybook and list the following:
     - Header, which are the fields that belong to the header. eg. TRNNAME, PGMNAME, CURDATE, CURTIME, TITLE01, TITLE02, etc.
     - How many sections of data is captured in the screen after the header? eg. Account Information, Customer Information
     - How many fields are there in each section? eg. Account Information has 10 fields
     - List the section label and its field in bullet points
     - If there is no section, write that the entire form is in one section only
     - Do not include in the sections fields like INFOMSG, ERRMSG, and FKEYS.

    4. For every field found in the COBOL copybook, include a separate Field Metadata analysis entry using the following template. Repeat this for all fields—do not omit any. Output as a list with bullet points
    - Section name
    - Field id: always use the originalId in the same format. If the original field has more than one ID (like date, phone numbers, etc), concatenate them with a "_". Example: "ID1_ID2"
    - Field originalIds: string array with all the original ids when it is a concatenated field
    - Field name
    - Field type: text, currency, number, select, radio, checkbox, etc.
    - Field options: array of options for select, radio, checkbox, etc. If not, add n/a
    - Field length: number of characters
    - Field description: description of the field
    - Initial value: initial value of the field, mandatory if the field is not editable. Provide currentDate, or currentTime when appropriate
    - Required or optional
    - Editable or readonly
    - Initial Cursor Position: true / false
    - Submit:  true / false based on the fieldSet attribute. Indicate if the payload should include this field
    - tabSequence: true / false - indicates if the field should be included in the tab sequence
    - FreeKeyboard: true / false
    - Position: This is the position of the field inside its section as row. e.g Row 1, Row 2, etc.
    - Validation rules: Indicate any validation rules for the field. Example: Y/N, numeric, date, etc.
    - Hidden: true / false - condition. For example: true when field X is Y
    - Any other relevant information for the business logic

    5. Before finishing, verify that every field defined in the COBOL copybook appears in the Field Metadata section of the output.
    6. Analyze all commands that the user can execute in the screen, the endpoint to call, payload to submit and what should happen when the user executes them. List all commands, labels, keys, and what should happen when the user executes them.
    7. Describe all business rules for the screen, including any validation rules, logic to hide and show fields, permissions, and API calls that shall be executed in on the process.
    8. Identify the navigation rules, to where the user should be routed after a command is executed.
    9. Summarize the text in a maximum of 500 characters, including the screen title, page type, sections, and fields. This is a summary for the business stakeholders.
    10. Don't put title on the markdown output. Start from the ScreenCode
    
    [SCREEN]
    ${screens?filter(it -> it.screenName == fileName)?first.screenCode!''}
    [/SCREEN]
  
    [COBOL CONTEXT]
    ${screens?filter(it -> it.screenName == fileName)?first.cobolCode!''}
    [/COBOL CONTEXT]
  emptyDiagram: |-
    data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAADnUlEQVR4nO2aSU8UURDHf0aEMRiRQUBvcjQY9UuooKjIze2m0YtL0KvLGT2ZmPA5NEggUYMrAu6JAsrJ5aLx5ghRM6biv5MKztLd07NI+CedDLyq6nqv6tWrqtewjKWLNNALXAGGgGngG7Cgx36/1ZjR7AeaqRGkgKPAKPAbyEZ8fgEjwBGgoRoTWA2cAz47peaBO8AFWWazVnyVnmb9z8YuAnfFE/B/Avq1OBXBHmDOKTAJHAOaYshaBxwHppy890A3ZYSt1KB74VNgZ4Lyu4DnTv71clhngxS3F3wHTgErk34Jf2WeATLO2u1JCe+QubOKOlsoP7YCM3rnO+lQElqdwAlgPZVDM/BA756TV8RCyrnTI6CRyqMRGHduFmvPDDp3ssOuWmhxXmEBIHKIDTZ2JfZEmD2TkU4W3UIfdsE5YdGpVnDWbf5QLnbenRPlCLFxUQe8kG42qYJoUKpgxDuoPeyWbp+LWeWIixBhcU8pRlsMxdpk+fsh6Ve4SHqoEOGoiCx3CosJ8byOOJk28Rjvkwh8J8QznI8grbR6PmIC6BUKO5k4PP6gtPrmZz49D0jwbeJlAK/cubMxAm2cE3tM/HtzDV7VoNUTcRBmlUuxhMdlyRggB4Y0uI/4KGSZJCyx2HtukAOzGrQqrhTkWvWkLBGgU7KsL/APvmrQcptSsVjxJCeBsnCT94UcWNBgPcnAu1IS7rT44A76BFWZSKFoFgUFJ7JkXGt2qWz2IQ1aBzAuCoXYKIdmMfQVCr/BgWjNs//6QOzVoHULoyLKYZeEZcbE35MvGQuSRusA1mrSmHZJ49p8RCMSbm3MsJhMII23UiAsTornViGiwyKyQiksHpdYWE1JRhhYYfVMOh4sdtB8FOEuag890u1DmGuIfhE/q8Hmw0vpdjoMQ8r1eq2hXCvol04zUS6FusWUUXOs2tgO/JBOka8yrrsVSCL/iotWNeVMl2txBKRcaB2vUhN7jTosQaeloZTVmHax3v6uFNLAQ3cdV/KFT4czrbnZNiqzJ97pnZaVb0pKcLtzs4x6rxYOk0adotMP505J1C//7JkgAGTVUE7q9nWFrjJeOvnXyn333uXMHnTtT8T8iiGt3ClIO7JypSRvi4ta56xLZ7LKSC29vqS+U6fCdr2eFl0a9YlmzPUJgrTjdLW+gGhQV3xYJUA24vNTlenBak0gF5rUi7Wq7aaKpq/uoxr7/Ubl6YBo89YTy+A/xx+3026HVKnF7QAAAABJRU5ErkJggg==
  retryDiagram: |-
    The following PlantUML code caused an error:
    
    !!diagram!!
    
    Please provide a corrected version of the PlantUML code.
  componentDiagramCypherQuery: |-
    @@@neo4j
    @@@jolt("${#recipe['templates']['joltNeo4jTableToJson']}")
    @@@set('project.currentCardCypherResults')
    @@@jsonify
    // Match COBOL Programs
    MATCH (program:COBOLProgram)
    
    // Match JCL Jobs
    OPTIONAL MATCH (job:JCLJob)
    WHERE job.name = 'TESTJCL'
    
    // Match Files used by the programs
    OPTIONAL MATCH (file:COBOLFile)
    WHERE file.name IN ['CUSTOMER-FILE', 'TRANSACTION-FILE', 'CUSTOMER-FILE-OUT', 'REPORT-FILE']
    
    // Match relationships between programs
    OPTIONAL MATCH (program1:COBOLProgram)-[call:CALLS]->(program2:COBOLProgram)
    WHERE program1.name = 'CUSTTRN1' AND program2.name = 'CUSTTRN2'
    
    // Match relationships between programs and files
    OPTIONAL MATCH (program:COBOLProgram)-[reads:READS]->(inputFile:COBOLFile)
    OPTIONAL MATCH (program:COBOLProgram)-[writes:WRITES]->(outputFile:COBOLFile)
    
    // Match relationships between JCL jobs and programs
    OPTIONAL MATCH (job:JCLJob)-[executes:EXECUTES]->(program:COBOLProgram)
    
    // Return all components and relationships
    RETURN program AS program, job AS job, file AS file, call AS call, reads AS reads, writes AS writes, executes AS executes
  jclProcessingFlowCypherQuery: |-
    @@@neo4j
    @@@jolt("${#recipe['templates']['joltNeo4jTableToJson']}")
    @@@set('project.currentCardCypherResults')
    @@@jsonify
    MATCH (jcl:COBOLJcl)
    OPTIONAL MATCH (jcl)-[]->(program:COBOLProgram)
    RETURN jcl AS jcl, program AS program
  ioCallgraphCypherQuery: |-
    @@@neo4j
    @@@jolt("${#recipe['templates']['joltNeo4jTableToJson']}")
    @@@set('ios')
    MATCH (par:COBOLParagraph)-[:CONTAINS]->(f)
    WHERE f:COBOLFileOperation OR f:Db2Table
    RETURN  apoc.text.replace(par.name, '-', '_')                                   AS paragraphLabel,
            apoc.text.replace(par.programName, '-', '_')                            AS programLabel, 
            f.name                                                                  AS dataObjectName, 
            apoc.text.replace(f.name, '-', '_')                                     AS dataObjectLabel, 
            CASE WHEN labels(f)[0] = 'Db2Table' THEN 'Table' ELSE 'File' END        AS dataObjectType,
            CASE WHEN f.sqlClause CONTAINS 'SELECT' OR f.operation = 'input' THEN 'READ' ELSE 'WRITE' END AS rw
  flowCallgraphCypherQuery: |-
    @@@neo4j
    @@@jolt("${#recipe['templates']['joltNeo4jTableToJson']}")
    @@@set('flows')
    WITH [
        '#FF6347',  // Tomato
        '#87CEFA',  // LightSkyBlue
        '#3CB371',  // MediumSeaGreen
        '#FFD700',  // Gold
        '#8A2BE2',  // BlueViolet
        '#FF69B4',  // HotPink
        '#4682B4',  // SteelBlue
        '#00CED1',  // DarkTurquoise
        '#FFA500',  // Orange
        '#4B0082'   // Indigo
      ] AS hexPalette
  
    MATCH (prog:COBOLProgram)-[:CONTAINS]->(:COBOLProcedureDivision)-[:CONTAINS]->(par:COBOLParagraph)
    OPTIONAL MATCH (par)-[:CONTAINS]->(per:COBOLPerform)
    WITH prog, par, per, hexPalette, size(hexPalette) AS paletteSize,
         [p IN COLLECT(per) WHERE p IS NOT NULL | {name: p.name, label: apoc.text.replace(p.name, '-', '_')}] AS performs
  
    WITH prog, {
           name: par.name,
           label: apoc.text.replace(par.name, '-', '_'),
           isEntryPoint: par.procedureDivisionOrder = 1,
           performs: performs
         } AS paragraph,
         hexPalette, paletteSize

    WITH prog, COLLECT(paragraph) AS paragraphs, hexPalette, paletteSize, CASE WHEN EXISTS {(:COBOLProgram)-[:DEPENDS_ON]->(prog)} THEN 'Secondary' ELSE 'Main' END AS mainOrSecondary
    ORDER BY prog.name  // define order for indexing
    WITH COLLECT({prog: prog, mainOrSecondary: mainOrSecondary, paragraphs: paragraphs}) AS progList, hexPalette, paletteSize

    UNWIND RANGE(0, SIZE(progList)-1) AS idx
    WITH progList[idx] AS item, idx, hexPalette, paletteSize
    RETURN    item.prog.name                            AS name,
            item.mainOrSecondary                        AS mainOrSecondary,
            apoc.text.replace(item.prog.name, '-', '_') AS label,
            hexPalette[idx % paletteSize]               AS color,
            item.paragraphs                             AS paragraphs
  screenSummaryCypherQuery: |-
    @@@neo4j
    @@@jolt("${#recipe['templates']['joltNeo4jTableToJson']}")
    @@@set('screens')
    @@@jsonify
    MATCH (s:Screen)-[:SCREEN_FIELD]->(sf:ScreenField)
    OPTIONAL MATCH (cp:COBOLProgram)-[*]->(s)
    RETURN 
        s.name                    AS screenName,
        s.rawCode                 AS screenCode,
        cp.name                   AS cobolProgram, 
        cp.rawCode                AS cobolCode, 
        COLLECT(DISTINCT sf.name) AS listOfFields